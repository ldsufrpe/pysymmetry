{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PySymmetry","text":"<p>A SageMath-based Python library for applying group representation theory to problems with symmetry.</p>"},{"location":"#about-the-project","title":"About the Project","text":"<p><code>PySymmetry</code> is a powerful tool designed to simplify complex computational problems by leveraging their underlying symmetries. Many problems in physics, engineering, and mathematics involve systems that are symmetric under certain transformations (like rotations or reflections).</p> <p>The core feature of this library is the block diagonalization of equivariant operators. By finding a symmetry-adapted basis, <code>PySymmetry</code> can transform a large, complex matrix into a set of smaller, independent block matrices. This decomposition significantly simplifies subsequent calculations, such as finding eigenvalues, and leads to substantial performance improvements.</p>"},{"location":"#where-to-go-next","title":"Where to Go Next?","text":"<ul> <li> <p>New to <code>PySymmetry</code>?     Start with our step-by-step Installation Guide.</p> </li> <li> <p>Want to see it in action?     Follow the Tutorial to solve a real-world physics problem.</p> </li> <li> <p>Looking for specific functions or classes?     Check out the detailed API Reference.</p> </li> </ul>"},{"location":"api_core/","title":"Core API: pysymmetry","text":"<p>This module contains the central classes and functions for group theory and representations.</p>"},{"location":"api_core/#pysymmetry.FiniteGroup","title":"<code>pysymmetry.FiniteGroup</code>","text":"<p>               Bases: <code>PermutationGroup_generic</code></p>"},{"location":"api_core/#pysymmetry.FiniteGroup.regular_representation","title":"<code>regular_representation()</code>","text":"<p>Return the regular representation defined over the group.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- FiniteGroup ; a  Sage permutation group or a group of the class FiniteGroup.</li> </ul> <p>OUTPUT: The regular representation defined over the FiniteGroup given by self. </p> <p>EXAMPLES:</p> <p>We define the regular representation over the cyclic group of 4 elements ::</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(4)) \nsage: reg = G.regular_representation()\nsage: [reg(g) for g in G]\n[Linear transformation associated with element g=(), represented by the non-singular matrix:\n [1 0 0 0]\n [0 1 0 0]\n [0 0 1 0]\n [0 0 0 1]\n Representation space: Vector space of dimension 4 over Algebraic Field\n ,\n Linear transformation associated with element g=(1,2,3,4), represented by the non-singular matrix:\n [0 0 0 1]\n [1 0 0 0]\n [0 1 0 0]\n [0 0 1 0]\n Representation space: Vector space of dimension 4 over Algebraic Field\n ,\n Linear transformation associated with element g=(1,3)(2,4), represented by the non-singular matrix:\n [0 0 1 0]\n [0 0 0 1]\n [1 0 0 0]\n [0 1 0 0]\n Representation space: Vector space of dimension 4 over Algebraic Field\n ,\n Linear transformation associated with element g=(1,4,3,2), represented by the non-singular matrix:\n [0 1 0 0]\n [0 0 1 0]\n [0 0 0 1]\n [1 0 0 0]\n Representation space: Vector space of dimension 4 over Algebraic Field\n ]\n</code></pre> <p>We define the group of symmetries of regular hexagon and the regular representation over this group ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: G = FiniteGroup(generators)\nsage: reg = G.regular_representation()\nsage: g = G.an_element()\nsage: reg(g)\nLinear transformation associated with element g=(1,3)(4,6), represented by the non-singular matrix:\n[0 0 0 0 0 0 0 0 1 0 0 0]\n[0 0 0 0 0 0 1 0 0 0 0 0]\n[0 0 0 0 0 0 0 1 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 0 1]\n[0 0 0 0 0 0 0 0 0 1 0 0]\n[0 0 0 0 0 0 0 0 0 0 1 0]\n[0 1 0 0 0 0 0 0 0 0 0 0]\n[0 0 1 0 0 0 0 0 0 0 0 0]\n[1 0 0 0 0 0 0 0 0 0 0 0]\n[0 0 0 0 1 0 0 0 0 0 0 0]\n[0 0 0 0 0 1 0 0 0 0 0 0]\n[0 0 0 1 0 0 0 0 0 0 0 0]\nRepresentation space: Vector space of dimension 12 over Algebraic Field\n</code></pre> <p>We define the regular representation over the symmetric group of 4 simbols ::</p> <pre><code>sage: H = SymmetricGroup(4)\nsage: G = FiniteGroup(H);\nsage: reg = G.regular_representation();\nsage: g = G.an_element()\nsage: reg(g)\nLinear transformation associated with element g=(1,3,4), represented by the non-singular matrix:\n24 x 24 dense matrix over Algebraic Field\nRepresentation space: Vector space of dimension 24 over Algebraic Field\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.FiniteGroup.irreducible_representations","title":"<code>irreducible_representations(show_table=True)</code>","text":"<p>Return the number n of irreducible representations of self and the irreducibles representations.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- FiniteGroup ; a  Sage permutation group or a group of the class FiniteGroup.</li> <li><code>show_table</code> -- a boolean (default: <code>True</code>) ; shows a table of each irreducible representation applied at the generators of self.</li> </ul> If show_table=True; return number of irreducible representions and irreducible representions themselves. <p>If show_table=False; return the irreducible representions themselves. </p> <p>EXAMPLES:</p> <p>We define the symmetric group of 4 simbols and calculate its irreducible representations ::</p> <pre><code>sage: G = FiniteGroup(SymmetricGroup(4));\nsage: n, irr = G.irreducible_representations(False) #Irreducible representations\nsage: n\n5\nsage: irr(0)\nMap: \n From: Permutation FiniteGroup with generators [(1,2), (1,2,3,4)] \n To: Matrix group over Integer Ring with 2 generators ([1], [1]).\n\nsage: irr(4)\nMap: \n From: Permutation FiniteGroup with generators [(1,2), (1,2,3,4)] \n To: Matrix group over Integer Ring with 2 generators (\n[ 0  1  0]  [ 0  0 -1]\n[ 1  0  0]  [ 0  1  0]\n[ 0  0 -1], [ 1  0  0]\n).\n</code></pre> <p>We define the representation by permutation on the cyclic group calculate its irreducible representations ::</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(6))\nsage: irr = G.irreducible_representations(True) #Irreducible representations\n||||||SAIDA A SER PENSADA|||||||\n</code></pre> <p>We calculate the irreducible representations of the group of symmetries of a regular tetrahedron ::</p> <pre><code>sage: G = FiniteGroup(AlternatingGroup(4));\nsage: irr = G.irreducible_representations(True) #Irreducible representations\nsage: for j in range(n):\n ||||||SAIDA A SER PENSADA|||||||\n</code></pre> <p>We define the group of symmetries of regular hexagon and calculate its irreducible representations  ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: G = FiniteGroup(PermutationGroup(generators))\nsage: n,irr = G.irreducible_representations(False) #Irreducible representations\nsage: for j in range(n):\n        print(irr(j))\nMap: \n From: Permutation FiniteGroup with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n To: Matrix group over Integer Ring with 2 generators ([1], [1]).\nMap: \n From: Permutation FiniteGroup with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n To: Matrix group over Integer Ring with 2 generators ([1], [-1]).\nMap: \n From: Permutation FiniteGroup with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n To: Matrix group over Integer Ring with 2 generators ([-1], [-1]).\nMap: \n From: Permutation FiniteGroup with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n To: Matrix group over Integer Ring with 2 generators ([-1], [1]).\nMap: \n From: Permutation FiniteGroup with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n To: Matrix group over Universal Cyclotomic Field with 2 generators (\n[E(3)^2      0]  [0 1]\n[     0   E(3)], [1 0]\n).\nMap: \n From: Permutation FiniteGroup with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n To: Matrix group over Universal Cyclotomic Field with 2 generators (\n[-E(3)^2       0]  [ 0 -1]\n[      0   -E(3)], [-1  0]\n).\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.FiniteGroup.natural_representation","title":"<code>natural_representation(field=QQbar)</code>","text":"<p>Return the natural representation of the group.</p> <p>The natural representation is defined by the permutation matrices associated with each element of the group.</p> <p>INPUT:</p> <ul> <li><code>field</code> -- (default: <code>QQbar</code>); The field over which the representation is defined.</li> </ul> <p>OUTPUT: A representation of the group.</p> <p>EXAMPLES:</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(4))\nsage: nat_rep = G.natural_representation()\nsage: g = G.an_element()\nsage: nat_rep(g).matrix()\n[0 1 0 0]\n[0 0 1 0]\n[0 0 0 1]\n[1 0 0 0]\n</code></pre>"},{"location":"api_core/#pysymmetry.FiniteGroup.isotypic_projection","title":"<code>isotypic_projection(right)</code>","text":"<p>Return a list containing the matrices associated to projections operators over the isotypic components(or conglomerates) of right.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- FiniteGroup ; a  Sage permutation group or a group of the class FiniteGroup.</li> <li><code>right</code> -- representation ; a representation defined over the same group as self.</li> </ul> <p>OUTPUT: A list of matrices representing the projections operators over the isotypics subespaces of right.</p> <p>EXAMPLES:</p> <p>We define the symmetric group of 3 simbols and the isotypic projections associated to the regular representation of this group ::</p> <pre><code>sage: G = FiniteGroup(SymmetricGroup(3));\nsage: reg = G.regular_representation();\nsage: G.isotypic_projection(reg)\n [\n [1 1 1 1 1 1]  [ 1  1  1 -1 -1 -1]  [ 2 -1 -1  0  0  0]\n [1 1 1 1 1 1]  [ 1  1  1 -1 -1 -1]  [-1  2 -1  0  0  0]\n [1 1 1 1 1 1]  [ 1  1  1 -1 -1 -1]  [-1 -1  2  0  0  0]\n [1 1 1 1 1 1]  [-1 -1 -1  1  1  1]  [ 0  0  0  2 -1 -1]\n [1 1 1 1 1 1]  [-1 -1 -1  1  1  1]  [ 0  0  0 -1  2 -1]\n [1 1 1 1 1 1], [-1 -1 -1  1  1  1], [ 0  0  0 -1 -1  2]\n  ]\n</code></pre> <p>We calculate an irreducible representation of G, and the isotypic projection associated ::</p> <pre><code>sage: n,irr = G.irreducible_representations(False) #Irreducible representations\nsage: G.isotypic_projection(irr(2))\n[\n[3 0]\n[0 3]\n]\n</code></pre> <p>We define the representation by permutation on the cyclic group and calculate the isotypic projectors ::</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: G.isotypic_projection(rep)\n[\n[1 1 1 1]  [ 1 -1  1 -1]  [   1 -1*I   -1  1*I]  [   1  1*I   -1 -1*I]\n[1 1 1 1]  [-1  1 -1  1]  [ 1*I    1 -1*I   -1]  [-1*I    1  1*I   -1]\n[1 1 1 1]  [ 1 -1  1 -1]  [  -1  1*I    1 -1*I]  [  -1 -1*I    1  1*I]\n[1 1 1 1], [-1  1 -1  1], [-1*I   -1  1*I    1], [ 1*I   -1 -1*I    1]\n]\n</code></pre> <p>We define a representation the group of symmetries of regular hexagon and calculate their isotypic projectors ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: rotation_pi_over_3, reflexion_about_x = matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])\nsage: matrices = [block_diagonal_matrix(rotation_pi_over_3, rotation_pi_over_3),block_diagonal_matrix(reflexion_about_x, reflexion_about_x)];\nsage: rep = representation(generators, matrices, field=SR)\nsage: G = rep.domain()\nsage: G.isotypic_projection(rep)\n[\n[6 0 0 0]\n[0 6 0 0]\n[0 0 6 0]\n[0 0 0 6]\n]\n</code></pre> <p>TO ADD MORE EXAMPLES TO ADD MORE EXAMPLES TO ADD MORE EXAMPLES</p> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.FiniteGroup.isotypic_base","title":"<code>isotypic_base(rep, isotypic_components=False)</code>","text":"<p>Return a list with the basis for each isotypic components of rep or the basis change matrix associated to the isotypic decomposition.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- FiniteGroup ; a  Sage permutation group or a group of the class FiniteGroup.</li> <li><code>rep</code> -- representation ; a representation defined over the same group as self.</li> <li><code>isotypic_components</code> -- a boolean (default: <code>False</code>) ; if False returns the change base matrix, if True returns a list with a base for each isotypic component :: </li> </ul> <p>OUTPUT: A list with a basis for each isotypic subspace of rep or the change basis matrix to a form in blocks associated to isotypic components of rep.</p> <p>EXAMPLES:</p> <p>We define the symmetric group of 3 simbols change basis matrix associated to the isotypic decomposition  ::</p> <pre><code>sage: G = FiniteGroup(SymmetricGroup(3));\nsage: reg = G.regular_representation();\nsage: G.isotypic_base(reg, isotypic_components=False)\n[ 1| 1| 2 -1  0  0]\n[ 1| 1|-1  2  0  0]\n[ 1| 1|-1 -1  0  0]\n[ 1|-1| 0  0  2 -1]\n[ 1|-1| 0  0 -1  2]\n[ 1|-1| 0  0 -1 -1]\n</code></pre> <p>The isotypic basis for each irreducible subspace associated to the regular representation of this group ::</p> <pre><code>sage: G.isotypic_base(reg, isotypic_components=True)\n[\n[1]  [ 1]  [ 2 -1  0  0]\n[1]  [ 1]  [-1  2  0  0]\n[1]  [ 1]  [-1 -1  0  0]\n[1]  [-1]  [ 0  0  2 -1]\n[1]  [-1]  [ 0  0 -1  2]\n[1], [-1], [ 0  0 -1 -1]\n]\n</code></pre> <p>We define the representation by permutation on the cyclic group and calculate its isotypic decompositions ::</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: G.isotypic_base(rep, isotypic_components=True)\n[\n[1]  [ 1]  [   1]  [   1]\n[1]  [-1]  [ 1*I]  [-1*I]\n[1]  [ 1]  [  -1]  [  -1]\n[1], [-1], [-1*I], [ 1*I]\n]\n\nsage: change_basis = G.isotypic_base(rep, isotypic_components=False); change_basis\n[   1|   1|   1|   1]\n[   1|  -1| 1*I|-1*I]\n[   1|   1|  -1|  -1]\n[   1|  -1|-1*I| 1*I]\nsage: [rep(g).matrix() for g in G]\n[\n[1 0 0 0]  [0 1 0 0]  [0 0 1 0]  [0 0 0 1]\n[0 1 0 0]  [0 0 1 0]  [0 0 0 1]  [1 0 0 0]\n[0 0 1 0]  [0 0 0 1]  [1 0 0 0]  [0 1 0 0]\n[0 0 0 1], [1 0 0 0], [0 1 0 0], [0 0 1 0]\n]\nsage: [change_basis.inverse()*rep(g).matrix()*change_basis for g in G]\n[\n[1 0 0 0]  [   1    0    0    0]  [ 1  0  0  0]  [   1    0    0    0]\n[0 1 0 0]  [   0   -1    0    0]  [ 0  1  0  0]  [   0   -1    0    0]\n[0 0 1 0]  [   0    0  1*I    0]  [ 0  0 -1  0]  [   0    0 -1*I    0]\n[0 0 0 1], [   0    0    0 -1*I], [ 0  0  0 -1], [   0    0    0  1*I]\n]\n</code></pre> <p>We define a representation the group of symmetries of regular hexagon and calculate their matrix change basis(this representation is irreducible) ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: matrices = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])];\nsage: rep = representation(generators, matrices)\nsage: G = rep.domain()\nsage: G.isotypic_base(rep, isotypic_components=True)\n[\n[6 0]\n[0 6]\n]\n</code></pre> <p>TO ADD MORE EXAMPLES TO ADD MORE EXAMPLES TO ADD MORE EXAMPLES</p> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.FiniteGroup.projection","title":"<code>projection(i, j, k, right, left=None)</code>","text":"<p>Return the projection(or transfers operators) associated to irreducible subrepresentations of right.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- FiniteGroup ; a  Sage permutation group or a group of the class FiniteGroup.</li> <li><code>right</code> -- representation ; a representation defined over the same group as self.</li> <li><code>i,j,k</code> --  integers ; integers numbers representing the projection(or transfer) chosen;         i- will choose the irreducible representation, and its range is from 0 until the number of irreducibles. ::<pre><code>j- choose a row of the matrix presentation of the irreducible, its range is the degree of chosen irreducible according i. ::\n\nk- choose a column of the matrix presentation of the irreducible, its range is the degree of chosen irreducible according i. ::\n</code></pre> </li> </ul> A matrix associated to the operator that projects over an irreducible subrepresentation of right(if j=k), or is a isomorphism between two equivalent subrepresentations of right. <p>Whenever the irreducible, chosen by index i, it is not a subrepresentation of right this matrix will be null.</p> <p>EXAMPLES:</p> <p>We define the representation by permutation on the cyclic group of four elements and calculate its projectors  ::</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: G.projection(0,0,0, rep)\n[1 1 1 1]\n[1 1 1 1]\n[1 1 1 1]\n[1 1 1 1]\nsage: n, irr = G.irreducible_representations(False)\nsage: list_of_projectors=[];\nfor i in range(n): # Choosing the irreducible\n    degree= irr(i).degree() # Calculation the degree of the irreducible\n    j=0;# we will use the first row\n    for k in range(degree):\n        projector = G.projection(i,j,k, rep);\n        list_of_projectors.append(projector)\nsage: list_of_projectors\n[\n[1 1 1 1]  [ 1 -1  1 -1]  [ 1 -I -1  I]  [ 1  I -1 -I]\n[1 1 1 1]  [-1  1 -1  1]  [ I  1 -I -1]  [-I  1  I -1]\n[1 1 1 1]  [ 1 -1  1 -1]  [-1  I  1 -I]  [-1 -I  1  I]\n[1 1 1 1], [-1  1 -1  1], [-I -1  I  1], [ I -1 -I  1]\n]\n</code></pre> <p>We define a representation on the group of symmetries of regular hexagon and calculate its projectors ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: matrices = [matrix([[1,0,0],[0,1/2,-sqrt(3)/2],[0,sqrt(3)/2,1/2]]),matrix([[1,0,0],[0,-1,0],[0,0,1]])];\nsage: rep = representation(generators, matrices)\nsage: G = rep.domain()\nsage: G.projection(0,0,0, rep)\n[     12       0       0]\n[      0       0 0.?e-18]\n[      0 0.?e-18       0]\nsage: n, irr = G.irreducible_representations(False)\nsage: list_of_projectors=[];\nfor i in range(n): # Choosing the irreducible\n    degree= irr(i).degree() # Calculation the degree of the irreducible\n    j=0;# we will use the first row\n    for k in range(degree):\n        projector = G.projection(i,j,k, rep);\n        list_of_projectors.append(view(projector, latex=False)) # view creates a better visualization\nsage: list_of_projectors\n[\n[12  0  0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]\n[ 0  0  0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]\n[ 0  0  0], [0 0 0], [0 0 0], [0 0 0], [0 0 0], [0 0 0],\n\n[   0    0    0]  [  0   0   0]\n[   0    3  3*I]  [  0   3 3*I]\n[   0 -3*I    3], [  0 3*I  -3]\n]\n</code></pre> <p>We define the regular representation over the symmetric group of 3 simbols and we calculate one of its projectors ::</p> <pre><code>sage: G = FiniteGroup(SymmetricGroup(3)) \nsage: reg = G.regular_representation();\nsage: view(G.projection(2,1,1, reg),latex=False) # The function view creates a better visualization\n[                   1  1/2*I*sqrt(3) - 1/2 -1/2*I*sqrt(3) - 1/2                    0                    0                    0]\n[-1/2*I*sqrt(3) - 1/2                    1  1/2*I*sqrt(3) - 1/2                    0                    0                    0]\n[ 1/2*I*sqrt(3) - 1/2 -1/2*I*sqrt(3) - 1/2                    1                    0                    0                    0]\n[                   0                    0                    0                    1 -1/2*I*sqrt(3) - 1/2  1/2*I*sqrt(3) - 1/2]\n[                   0                    0                    0  1/2*I*sqrt(3) - 1/2                    1 -1/2*I*sqrt(3) - 1/2]\n[                   0                    0                    0 -1/2*I*sqrt(3) - 1/2  1/2*I*sqrt(3) - 1/2                    1]\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.FiniteGroup.base_to_irreducibles","title":"<code>base_to_irreducibles(right)</code>","text":"<p>Return the basis change matrix associated to a decomposition of right into irreducibles representations.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- FiniteGroup ; a  Sage permutation group or a group of the class FiniteGroup.</li> <li><code>right</code> -- representation ; a representation defined over the same group as self.</li> </ul> <p>OUTPUT: A change basis matrix that decomposes right in its irreducible components.</p> <p>EXAMPLES:</p> <p>We define the representation by permutation on the cyclic group of four elements and calculate its decomposition into irreducibles(Note that in this case because multiplicity we get the same result with the isotypic base)  ::</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: A = G.base_to_irreducibles(rep); A\n[ 1  1  1  1]\n[ 1 -1  I -I]\n[ 1  1 -1 -1]\n[ 1 -1 -I  I]\n\nsage: [rep(g).matrix() for g in G]\n[\n[1 0 0 0]  [0 1 0 0]  [0 0 1 0]  [0 0 0 1]\n[0 1 0 0]  [0 0 1 0]  [0 0 0 1]  [1 0 0 0]\n[0 0 1 0]  [0 0 0 1]  [1 0 0 0]  [0 1 0 0]\n[0 0 0 1], [1 0 0 0], [0 1 0 0], [0 0 1 0]\n]\n\nsage: [A.inverse()*rep(g).matrix()*A for g in G]\n[\n[1 0 0 0]  [ 1  0  0  0]  [ 1  0  0  0]  [ 1  0  0  0]\n[0 1 0 0]  [ 0 -1  0  0]  [ 0  1  0  0]  [ 0 -1  0  0]\n[0 0 1 0]  [ 0  0  I  0]  [ 0  0 -1  0]  [ 0  0 -I  0]\n[0 0 0 1], [ 0  0  0 -I], [ 0  0  0 -1], [ 0  0  0  I]\n]\n</code></pre> <p>We define a representation on the group of symmetries of regular hexagon and calculate its matrix change basis to decomposing into irreducible blocks ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: P = matrix([[5,3,4],[0,3,4],[0,0,4]]);P\nsage: matrices = [P.inverse()*matrix([[1,0,0],[0,1/2,-sqrt(3)/2],[0,sqrt(3)/2,1/2]])*P,P.inverse()*matrix([[1,0,0],[0,-1,0],[0,0,1]])*P];\nsage: rep = representation(generators, matrices, field=QQbar)\nsage: G = rep.domain()\nsage: B = G.base_to_irreducibles(rep); \nsage: view(B,latex=False) # This function creates a better visualization of the matrix\n[        12       -9/5      -54/5]\n[         0    3*I + 3 -18*I + 18]\n[         0     -9/4*I     27/2*I]\n\nsage: [view(rep(g).matrix(), latex=False) for g in G]\n[\n[1 0 0]  [                 1               9/10 -2/5*sqrt(3) + 6/5]\n[0 1 0]  [                 0  1/2*sqrt(3) - 1/2        4*sqrt(1/3)]\n[0 0 1], [                 0       -3/8*sqrt(3) -1/2*sqrt(3) - 1/2],\n\n[                 1               9/10  2/5*sqrt(3) + 6/5]\n[                 0 -1/2*sqrt(3) - 1/2       -4*sqrt(1/3)]\n[                 0        3/8*sqrt(3)  1/2*sqrt(3) - 1/2],\n\n[                 1               3/10 -2/5*sqrt(3) + 2/5]\n[                 0  1/2*sqrt(3) + 1/2        4*sqrt(1/3)]\n[                 0       -3/8*sqrt(3) -1/2*sqrt(3) + 1/2],\n\n[  1 6/5 8/5]\n[  0  -1   0]\n[  0   0  -1],\n\n[                 1               3/10  2/5*sqrt(3) + 2/5]\n[                 0 -1/2*sqrt(3) + 1/2       -4*sqrt(1/3)]\n[                 0        3/8*sqrt(3)  1/2*sqrt(3) + 1/2],\n\n[  1   0   0]\n[  0   1 8/3]\n[  0   0  -1],\n\n[                 1               9/10 -2/5*sqrt(3) + 6/5]\n[                 0 -1/2*sqrt(3) - 1/2               -4/3]\n[                 0        3/8*sqrt(3)  1/2*sqrt(3) + 1/2],\n\n[                 1               9/10  2/5*sqrt(3) + 6/5]\n[                 0  1/2*sqrt(3) - 1/2               -4/3]\n[                 0       -3/8*sqrt(3) -1/2*sqrt(3) + 1/2],\n\n[                 1               3/10 -2/5*sqrt(3) + 2/5]\n[                 0 -1/2*sqrt(3) + 1/2                4/3]\n[                 0        3/8*sqrt(3)  1/2*sqrt(3) - 1/2],\n\n[   1  6/5  8/5]\n[   0   -1 -8/3]\n[   0    0    1],\n\n[                 1               3/10  2/5*sqrt(3) + 2/5]\n[                 0  1/2*sqrt(3) + 1/2                4/3]\n[                 0       -3/8*sqrt(3) -1/2*sqrt(3) - 1/2]\n]\n\nsage: [view(B.inverse()*rep(g).matrix()*B, latex=False) for g in G]\n[\n[1 0 0]\n[0 1 0]\n[0 0 1],\n\n[                   1                    0                    0]\n[                   0 -1/2*I*sqrt(3) - 1/2                    0]\n[                   0                    0  1/2*I*sqrt(3) - 1/2],\n\n[                   1                    0                    0]\n[                   0  1/2*I*sqrt(3) - 1/2                    0]\n[                   0                    0 -1/2*I*sqrt(3) - 1/2],\n\n[                   1                    0                    0]\n[                   0 -1/2*I*sqrt(3) + 1/2                    0]\n[                   0                    0  1/2*I*sqrt(3) + 1/2],\n\n[ 1  0  0]\n[ 0 -1  0]\n[ 0  0 -1],\n\n[                   1                    0                    0]\n[                   0  1/2*I*sqrt(3) + 1/2                    0]\n[                   0                    0 -1/2*I*sqrt(3) + 1/2],\n\n[  1   0   0]  [                      1                       0                       0]\n[  0   0   6]  [                      0                       0         3*I*sqrt(3) - 3]\n[  0 1/6   0], [                      0 -1/4*I*sqrt(1/3) - 1/12                       0],\n\n[                     1                      0                      0]  [                      1                       0                       0]\n[                     0                      0       -3*I*sqrt(3) - 3]  [                      0                       0         3*I*sqrt(3) + 3]\n[                     0 1/4*I*sqrt(1/3) - 1/12                      0], [                      0 -1/4*I*sqrt(1/3) + 1/12                       0],\n\n[   1    0    0]\n[   0    0   -6]\n[   0 -1/6    0],\n\n[                     1                      0                      0]\n[                     0                      0       -3*I*sqrt(3) + 3]\n[                     0 1/4*I*sqrt(1/3) + 1/12                      0]\n]\n</code></pre> <p>We define the regular representation over the symmetric group of 3 simbols and we decompose into irreducible components ::</p> <pre><code>sage: G = FiniteGroup(SymmetricGroup(3)) \nsage: reg = G.regular_representation();\nsage: C = G.base_to_irreducibles(reg); \nsage: view(C, latex=False) # This Function creates a better visualization of the matrix\n[                   1                    1                    1                    0                    0                    3]\n[                   1                    1  1/2*I*sqrt(3) - 1/2                    0                    0 -3/2*I*sqrt(3) - 3/2]\n[                   1                    1 -1/2*I*sqrt(3) - 1/2                    0                    0  3/2*I*sqrt(3) - 3/2]\n[                   1                   -1                    0                    3                    1                    0]\n[                   1                   -1                    0  3/2*I*sqrt(3) - 3/2 -1/2*I*sqrt(3) - 1/2                    0]\n[                   1                   -1                    0 -3/2*I*sqrt(3) - 3/2  1/2*I*sqrt(3) - 1/2                    0]\n\nsage: g = G.an_element();\nsage: reg(g).matrix()\n[0 0 0 0 0 1]\n[0 0 0 1 0 0]\n[0 0 0 0 1 0]\n[0 1 0 0 0 0]\n[0 0 1 0 0 0]\n[1 0 0 0 0 0]\n\nsage: A = C.inverse()*reg(g).matrix()*C;\nsage: view(A, latex=False)\n[                    1                     0                     0                     0                     0                     0]\n[                    0                    -1                     0                     0                     0                     0]\n[                    0                     0                     0  -3/2*I*sqrt(3) - 3/2                     0                     0]\n[                    0                     0 1/2*I*sqrt(1/3) - 1/6                     0                     0                     0]\n[                    0                     0                     0                     0                     0  -3/2*I*sqrt(3) - 3/2]\n[                    0                     0                     0                     0 1/2*I*sqrt(1/3) - 1/6                     0]\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.FiniteGroup.base_equivariant_to_blocks","title":"<code>base_equivariant_to_blocks(right, row=0)</code>","text":"<p>Return the basis change matrix associated to a symmetry adapted basis to an equivariant operator of right.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- FiniteGroup ; a  Sage permutation group or a group of the class FiniteGroup.</li> <li><code>right</code> -- representation ; a representation defined over the same group as self.</li> <li><code>row</code> -- an integer (default: 0) ; an integer in the range of the degree of right, this number will choose the set o projectors to be chosen in the contruction of the base :: </li> </ul> <p>OUTPUT: A change basis matrix that decomposes the equivariant operator.</p> <p>EXAMPLES:</p> <p>We define the representation by permutation on the cyclic group of four elements and decompose an equivariant operator under this representation  ::</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: A = matrix.circulant([1,2,3,4])\nsage: rep.is_equivariant_to(A)\nTrue\nsage: P = G.base_equivariant_to_blocks(rep); P\n[ 1  1  1  1]\n[ 1 -1  I -I]\n[ 1  1 -1 -1]\n[ 1 -1 -I  I]\nsage: A, P.inverse()*A*P\n(\n[1 2 3 4]  [      10        0        0        0]\n[4 1 2 3]  [       0       -2        0        0]\n[3 4 1 2]  [       0        0 -2*I - 2        0]\n[2 3 4 1], [       0        0        0  2*I - 2]\n)\n</code></pre> <p>We define a representation on the permutation group, and decompose an equivariant operator  ::</p> <pre><code>sage: G = FiniteGroup(['(2,4)(3,7)(6,8)', '(1,3)(4,6)(7,9)'])\nsage: gens = G.gens()\nsage: matrices = [g.matrix() for g in gens]\nsage: rep = representation(gens, matrices)\nsage: operator = matrix([[ 4, -1, -0, -1, -0, -0, -0, -0, -0],\n                        [-1,  4, -1, -0, -1, -0, -0, -0, -0],\n                        [-0, -1,  4, -0, -0, -1, -0, -0, -0],\n                        [-1, -0, -0,  4, -1, -0, -1, -0, -0],\n                        [-0, -1, -0, -1,  4, -1, -0, -1, -0],\n                        [-0, -0, -1, -0, -1,  4, -0, -0, -1],\n                        [-0, -0, -0, -1, -0, -0,  4, -1, -0],\n                        [-0, -0, -0, -0, -1, -0, -1,  4, -1],\n                        [-0, -0, -0, -0, -0, -1, -0, -1,  4]])\nsage: rep.is_equivariant_to(operator)\nTrue\nsage: P = G.base_equivariant_to_blocks(rep); P\n[ 2  0  0  2  0  2  0  0  0]\n[ 0  2  0  0  2  0  1  0  4]\n[ 2  0  0 -2  0  0  0  8  0]\n[ 0  2  0  0 -2  0  1  0 -4]\n[ 0  0  8  0  0  0  0  0  0]\n[ 0  2  0  0 -2  0 -1  0  4]\n[ 2  0  0 -2  0  0  0 -8  0]\n[ 0  2  0  0  2  0 -1  0 -4]\n[ 2  0  0  2  0 -2  0  0  0]\nsage: operator, P.inverse()*operator*P\n(\n[ 4 -1  0 -1  0  0  0  0  0]  [ 4 -2  0  0  0  0  0  0  0]\n[-1  4 -1  0 -1  0  0  0  0]  [-2  4 -4  0  0  0  0  0  0]\n[ 0 -1  4  0  0 -1  0  0  0]  [ 0 -1  4  0  0  0  0  0  0]\n[-1  0  0  4 -1  0 -1  0  0]  [ 0  0  0  4  0  0  0  0  0]\n[ 0 -1  0 -1  4 -1  0 -1  0]  [ 0  0  0  0  4  0  0  0  0]\n[ 0  0 -1  0 -1  4  0  0 -1]  [ 0  0  0  0  0  4 -1  0  0]\n[ 0  0  0 -1  0  0  4 -1  0]  [ 0  0  0  0  0 -2  4  0  0]\n[ 0  0  0  0 -1  0 -1  4 -1]  [ 0  0  0  0  0  0  0  4 -1]\n[ 0  0  0  0  0 -1  0 -1  4], [ 0  0  0  0  0  0  0 -2  4]\n)\n</code></pre> <p>TO ADD MORE EXAMPLES TO ADD MORE EXAMPLES TO ADD MORE EXAMPLES</p> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.FiniteGroup.quick_block_prevision","title":"<code>quick_block_prevision(right, block_prevision=False)</code>","text":"<p>Return a list with order and multiplicities of blocks to an equivariant operator under right defined on self.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- FiniteGroup ; a  Sage permutation group or a group of the class FiniteGroup.</li> <li><code>right</code> -- representation ; a representation defined over an arbitrary group given by self.</li> <li><code>block_prevision</code> -- a boolean (default: <code>False</code>) ; if set to True then prints a string describing the number and orders of blocks to an equivariant operator under right.</li> </ul> <p>OUTPUT: A list indicating the degree and multiplicity of the representation defined by right. </p> <p>EXAMPLES:</p> <p>We define the regular representation(reg) over the symmetric group of 4 simbols and calculate the structure of an equivariant operator under reg ::</p> <pre><code>sage: H = SymmetricGroup(4)\nsage: G = FiniteGroup(H);\nsage: reg = G.regular_representation();\nsage: G.quick_block_prevision(reg)\n[['degree', 'multiplicity'], [1, 1], [1, 1], [2, 2], [3, 3], [3, 3]]\n\nsage: G.quick_block_prevision(reg, block_prevision=True)\n1 block size 1x1\n1 block size 1x1\n2 block size 2x2\n3 block size 3x3\n3 block size 3x3\n[['degree', 'multiplicity'], [1, 1], [1, 1], [2, 2], [3, 3], [3, 3]]\n</code></pre> <p>We define the representation by permutation on the cyclic group and calculate the structure of an equivariant operator ::</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: G.quick_block_prevision(rep, block_prevision=True)\n1 block size 1x1\n1 block size 1x1\n1 block size 1x1\n1 block size 1x1\n[['degree', 'multiplicity'], [1, 1], [1, 1], [1, 1], [1, 1]]\n</code></pre> <p>We calculate the irreducible representations of the group of symmetries of tetrahedron and calculate the structure of an equivariant operator inder its irreducibles ::</p> <pre><code>sage: G = FiniteGroup(AlternatingGroup(4));\nsage: n,irr = G.irreducible_representations(False) ##Irreducible representations\nsage: for j in range(n):\n        print(G.quick_block_prevision(irr(j),block_prevision=True))\n1 block size 1x1\n[['degree', 'multiplicity'], [1, 1]]\n1 block size 1x1\n[['degree', 'multiplicity'], [1, 1]]\n1 block size 1x1\n[['degree', 'multiplicity'], [1, 1]]\n3 block size 1x1\n[['degree', 'multiplicity'], [3, 1]]\n</code></pre> <p>We define two representation rep and rep1 on the group of symmetries of regular hexagon and calculate the structure of an equivariant operator under each one ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: matrices = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])];\nsage: rep = representation(generators, matrices)\nsage: G = rep.domain()\nsage: G.quick_block_prevision(rep,block_prevision=True)\n2 block size 1x1\n[['degree', 'multiplicity'], [2, 1]]\n\nsage: P = matrix([[2,1],[15,2]]); #A change of basis\nsage: matrices1 = [ block_diagonal_matrix((P.inverse())*A*P, (P.inverse())*A*P) for A in matrices];\nsage: rep1 = representation(generators, matrices1)\nsage: G.quick_block_prevision(rep1,block_prevision=True)\n2 block size 2x2\n[['degree', 'multiplicity'], [2, 2]]\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.FiniteGroup.base_change_eigenvalue_reduction_new","title":"<code>base_change_eigenvalue_reduction_new(right, block_prevision=False)</code>","text":"<p>Return part of basis change matrix associated to a symmetry adapted basis to an equivariant operator of right.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- FiniteGroup ; a  Sage permutation group or a group of the class FiniteGroup.</li> <li><code>right</code> -- representation ; a representation defined over the same group as self.        </li> <li><code>block_prevision</code> -- a boolean (default: <code>False</code>) ; if set to True then prints a string describing the number and orders of blocks to an equivariant operator under right.</li> </ul> <p>OUTPUT: A list of basis subespaces, along with degree and multiplicitie(number of equivalent copies). The restriction of an equivariant operator to each subespace gives a different block matrix of the equivariant operator relative to the symmetry adapted basis. In short, these are parts of the symmetry adapted basis that no generates block repetitions.</p> <p>EXAMPLES:</p> <p>We define the representation by permutation on the cyclic group of four elements and calculates the subspaces that gives one copy of each block of the equivariant operator under this representation  ::</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: G.base_change_eigenvalue_reduction_new(rep)\n([[\n[1]        \n[1]        \n[1]        \n[1], [1, 1]\n],\n  [\n[ 1]        \n[-1]        \n[ 1]        \n[-1], [1, 1]\n],\n  [\n[ 1]        \n[ I]        \n[-1]        \n[-I], [1, 1]\n],\n  [\n[ 1]        \n[-I]        \n[-1]        \n[ I], [1, 1]\n]],\n [['degree', 'multiplicity'], [1, 1], [1, 1], [1, 1], [1, 1]])\n\nsage: G.base_change_eigenvalue_reduction_new(rep, block_prevision=True)\n1 block size 1x1\n1 block size 1x1\n1 block size 1x1\n1 block size 1x1\n([[\n[1]        \n[1]        \n[1]        \n[1], [1, 1]\n],\n  [\n[ 1]        \n[-1]        \n[ 1]        \n[-1], [1, 1]\n],\n  [\n[ 1]        \n[ I]        \n[-1]        \n[-I], [1, 1]\n],\n  [\n[ 1]        \n[-I]        \n[-1]        \n[ I], [1, 1]\n]],\n [['degree', 'multiplicity'], [1, 1], [1, 1], [1, 1], [1, 1]])\n</code></pre> <p>We define a representation on the permutation group, and calculates parts of the symmetry adapted basis that generates no repetition in the blocks of an equivariant operator  ::</p> <pre><code>sage: G = FiniteGroup(['(2,4)(3,7)(6,8)', '(1,3)(4,6)(7,9)'])\nsage: gens = G.gens()\nsage: matrices = [g.matrix() for g in gens]\nsage: rep = representation(gens, matrices)\nsage: G.base_change_eigenvalue_reduction_new(rep)\n([[\n[2 0 0]        \n[0 2 0]        \n[2 0 0]        \n[0 2 0]        \n[0 0 8]        \n[0 2 0]        \n[2 0 0]        \n[0 2 0]        \n[2 0 0], [1, 3]\n],\n  [\n[ 2]        \n[ 0]        \n[-2]        \n[ 0]        \n[ 0]        \n[ 0]        \n[-2]        \n[ 0]        \n[ 2], [1, 1]\n],\n  [\n[ 0]        \n[ 2]        \n[ 0]        \n[-2]        \n[ 0]        \n[-2]        \n[ 0]        \n[ 2]        \n[ 0], [1, 1]\n],\n  [\n[ 2  0]        \n[ 0  1]        \n[ 0  0]        \n[ 0  1]        \n[ 0  0]        \n[ 0 -1]        \n[ 0  0]        \n[ 0 -1]        \n[-2  0], [2, 2]\n]],\n [['degree', 'multiplicity'], [1, 3], [1, 1], [1, 1], [2, 2]])\n</code></pre> <p>We define the regular representation(reg) over the symmetric group of 3 simbols and calculate the subspaces that gives all the blocks of an equivariant operator without repetition ::</p> <pre><code>sage: H = SymmetricGroup(3)\nsage: G = FiniteGroup(H);\nsage: reg = G.regular_representation();\nsage: G.base_change_eigenvalue_reduction_new(reg,block_prevision=True)\n1 block size 1x1\n1 block size 1x1\n2 block size 2x2\n([[\n[1]        \n[1]        \n[1]        \n[1]        \n[1]        \n[1], [1, 1]\n],\n  [\n[ 1]        \n[ 1]        \n[ 1]        \n[-1]        \n[-1]        \n[-1], [1, 1]\n],\n  [\n[                                         1                                          0]\n[-0.500000000000000? + 0.866025403784439?*I                                          0]\n[-0.500000000000000? - 0.866025403784439?*I                                          0]\n[                                         0                                          1]\n[                                         0 -0.500000000000000? - 0.866025403784439?*I]\n[                                         0 -0.500000000000000? + 0.866025403784439?*I],\n\n[2, 2]\n]],\n [['degree', 'multiplicity'], [1, 1], [1, 1], [2, 2]])\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.MapRepresentation","title":"<code>pysymmetry.MapRepresentation</code>","text":"<p>               Bases: <code>SetMorphism</code></p>"},{"location":"api_core/#pysymmetry.MapRepresentation.inner_product","title":"<code>inner_product(right)</code>","text":"<p>Return the inner product between self and right.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- representation ; a representation defined over an arbitrary group G.</li> <li><code>right</code> -- representation ; a representation defined over the same group as self.</li> </ul> <p>OUTPUT: The inner product between the two representations defined on the group G. </p> <p>EXAMPLES:</p> <p>We define the representation by permutation on the cyclic group of 4 elements and calculate its inner products with the trivial representation ::</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: n,irr = G.irreducible_representations(False) #Irreducible representations\nsage: rep.inner_product(irr(0))\n1\n</code></pre> <p>We define one representation on the group of symmetries of regular hexagon and calculate the inner product with itself ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: matrices = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])];\nsage: rep = representation(generators, matrices)\nsage: rep.inner_product(rep)\n1\n</code></pre> <p>We define the regular representation over the symmetric group of 4 simbols and calculate the inner products between the regular representation and the irreducible representations ::</p> <pre><code>sage: H = SymmetricGroup(4)\nsage: G = FiniteGroup(H);\nsage: n,irr = G.irreducible_representations(False) #Irreducible representations\nsage: reg = G.regular_representation();\nsage: [reg.inner_product(irr(j)) for j in range(n)] # The inner product between the regular and irreducibles\n[1, 1, 2, 3, 3]\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.MapRepresentation.direct_sum","title":"<code>direct_sum(*reps)</code>","text":"<p>INPUT: A list of representations. OUTPUT: Their direct sum</p>"},{"location":"api_core/#pysymmetry.MapRepresentation.an_element","title":"<code>an_element()</code>","text":"<p>Return an image of an element of the group under self.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- representation ; a representation defined over an arbitrary group G.</li> </ul> <p>OUTPUT: A linear transformation corresponding to the image under self of a random element of the group G. </p> <p>EXAMPLES:</p> <p>We define the cyclic group of 4 elements and choose an element to show its image under self ::</p> <pre><code>sage: G = CyclicPermutationGroup(4) \nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: rep.an_element()\nLinear transformation associated with element g=(1,2,3,4), represented by the non-singular matrix:\n[0 1 0 0]\n[0 0 1 0]\n[0 0 0 1]\n[1 0 0 0]\nRepresentation space: Vector space of dimension 4 over Algebraic Field\n</code></pre> <p>We define one representation on the group of symmetries of regular hexagon and show the image of an element of the group ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: matrices = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])];\nsage: rep = representation(generators, matrices)\nsage: rep.an_element()\nLinear transformation associated with element g=(1,3)(4,6), represented by the non-singular matrix:\n[               -1/2 -0.866025403784439?]\n[-0.866025403784439?                 1/2]\nRepresentation space: Vector space of dimension 2 over Algebraic Field\n</code></pre> <p>We define the regular representation over the symmetric group of 4 simbols and calculate the image of a random element ::</p> <pre><code>sage: H = SymmetricGroup(4)\nsage: G = FiniteGroup(H);\nsage: reg = G.regular_representation();\nsage: reg.an_element()\nLinear transformation associated with element g=(1,3,4), represented by the non-singular matrix:\n24 x 24 dense matrix over Algebraic Field\nRepresentation space: Vector space of dimension 24 over Algebraic Field\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.MapRepresentation.degree","title":"<code>degree()</code>","text":"<p>Return the degree of a representation defined over an arbitrary group G.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- representation; a representation defined over an arbitrary group G.</li> </ul> <p>OUTPUT: The degree of self, i.e. , the dimension of the subjacent vector space of self. </p> <p>EXAMPLES:</p> <p>We define the representation by permutation on the cyclic group of 4 elements ::</p> <pre><code>sage: G = CyclicPermutationGroup(4) \nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: rep.degree()\n4\n</code></pre> <p>We define one representation on the group of symmetries of regular hexagon ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: matrices1 = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])];\nsage: rep = representation(generators, matrices1)\nsage: rep.degree()\n2\n</code></pre> <p>We define the regular representation over the symmetric group of 4 simbols and calculate its degree ::</p> <pre><code>sage: H = SymmetricGroup(4)\nsage: G = FiniteGroup(H);\nsage: reg = G.regular_representation();\nsage: reg.degree()\n24\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.MapRepresentation.is_equivariant_to","title":"<code>is_equivariant_to(M)</code>","text":"<p>Tests if an operator is equivariant to a representation defined over a an arbitrary group G.</p> <p>INPUT:</p> <ul> <li> <p><code>M</code> -- matrix ; a square matrix associated to an operator over a representation vector space.</p> </li> <li> <p><code>self</code> -- representation; a representation defined over an arbitrary group G.</p> </li> </ul> <p>OUTPUT: True if the operator is equivariant or False if is not equivariant.</p> <p>EXAMPLES:</p> <p>Define the representation by permutation on the cyclic group of 4 elements ::</p> <pre><code>sage: G = CyclicPermutationGroup(4) \nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: v = [1,2,3,4]\nsage: A = matrix.circulant(v); \nsage: rep.is_equivariant_to(A)\nTrue\nsage: B = matrix.circulant(SR.var('a b c d'))\nsage: rep.is_equivariant_to(B)\nTrue\n</code></pre> <p>We define a representation over the symmetric group and test if the identity is equivariant ::</p> <pre><code>sage: G = SymmetricGroup(5)\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices, field=AA)\nsage: rep.is_equivariant_to(identity_matrix(AA, 5))\nTrue\nsage: C = matrix.hilbert(5).change_ring(AA);\nsage: rep.is_equivariant_to(C);\nFalse\n</code></pre> <p>ENRIQUECER QUANDO DEFINIR PRODUTO TENSORIAL OU SOMA DIRETA.</p> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.MapRepresentation.is_unitary","title":"<code>is_unitary()</code>","text":"<p>Tests if a representation defined over an arbitrary group G is unitary.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- representation; a representation defined over an arbitrary group G.</li> </ul> <p>OUTPUT: True if the representation is unitary or False if is not unitary.</p> <p>EXAMPLES:</p> <p>Define the representation by permutation on the cyclic group of 4 elements ::</p> <pre><code>sage: G = CyclicPermutationGroup(4) \nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: rep.is_unitary()\nTrue\n</code></pre> <p>Define two representations on the group of symmetries of regular hexagon ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: P = matrix([[2,1],[15,2]]); ## A non-unitary base change\nsage: matrices1 = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])];\nsage: matrices2 = [P.inverse()*A*P for A in matrices1]\nsage: rep1 = representation(generators, matrices1)\nsage: rep2 = representation(generators, matrices2)\nsage: rep1.is_unitary(), rep2.is_unitary()\n(True, False)\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.MapRepresentation.is_irreducible","title":"<code>is_irreducible()</code>","text":"<p>Tests if a representation defined over an arbitrary group G is irreducible.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- representation; a representation defined over an arbitrary group G.</li> </ul> <p>OUTPUT: True if the representation is irreducible  or False if is reducible.</p> <p>EXAMPLES:</p> <p>Define the representation by permutation on the cyclic group of 6 elements ::</p> <pre><code>sage: G = CyclicPermutationGroup(6) \nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: rep.is_irreducible()\nFalse\n</code></pre> <p>Define one representation on the group of symmetries of regular hexagon ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: matrices = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])];\nsage: rep = representation(generators, matrices)\nsage: rep.is_irreducible()\nTrue\n</code></pre> <p>We define the regular representation over the symmetric group of 4 simbols and ask if is irreducible ::</p> <pre><code>sage: H = SymmetricGroup(4)\nsage: G = FiniteGroup(H);\nsage: reg = G.regular_representation();\nsage: reg.is_irreducible()\nFalse\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.MapRepresentation.is_representation","title":"<code>is_representation()</code>","text":"<p>Test whether self is a group representation (homomorphism) on its domain.</p> <p>A map \u03c1: G \u2192 GL(V) is a representation if \u03c1(gh) = \u03c1(g) \u03c1(h) for all g, h in G. This method verifies the homomorphism property by checking all pairs in the finite domain group. For large groups this can be slow.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- representation; a mapping from a finite group G to a matrix group.</li> </ul> <code>True</code> if the map preserves the group operation (homomorphism); <p>otherwise <code>False</code>.</p> <p>EXAMPLES:</p> <p>We define the permutation representation of the cyclic group of order 4 and test the homomorphism property ::</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(4))\nsage: gens = G.gens()\nsage: mats = [g.matrix() for g in gens]\nsage: rep = representation(gens, mats)\nsage: rep.is_representation()\nTrue\n</code></pre> <p>We also check a representation over the dihedral group of order 12 ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\", \"(1,4)(2,3)(5,6)\"]\nsage: matrices = [matrix([[1/2, -sqrt(3)/2],[sqrt(3)/2, 1/2]]), matrix([[-1,0],[0,1]])]\nsage: rep = representation(generators, matrices)\nsage: rep.is_representation()\nTrue\n</code></pre> <p>REFERENCES:</p> <ul> <li>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. Springer, 1977.</li> <li>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer, 2012.</li> </ul>"},{"location":"api_core/#pysymmetry.MapRepresentation.is_stable","title":"<code>is_stable(subspace)</code>","text":"<p>Test whether a given subspace is stable (invariant) under the representation.</p> <p>A subspace W \u2286 V is stable under the representation \u03c1 if \u03c1(g)\u00b7w \u2208 W for every generator g of G and every w in a basis of W. This method verifies invariance using the group generators.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- representation; a representation of a finite group G on V.</li> <li><code>subspace</code> -- vector subspace; a Sage vector subspace of V.</li> </ul> <code>True</code> if <code>subspace</code> is invariant under the action of the generators <p>of the group; otherwise <code>False</code>. A <code>TypeError</code> is raised if <code>subspace</code> is not a subspace of the representation space V.</p> <p>EXAMPLES:</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(4))\nsage: gens = G.gens()\nsage: mats = [g.matrix() for g in gens]\nsage: rep = representation(gens, mats)\nsage: V = (rep.an_element()).domain()        # representation space V\nsage: e1 = V.basis()[0]\nsage: W = V.subspace([e1])                   # span{e1}\nsage: rep.is_stable(W) in [True, False]      # doctest: +ELLIPSIS\nTrue\n</code></pre> <p>REFERENCES:</p> <ul> <li>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. Springer, 1977.</li> <li>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer, 2012.</li> </ul>"},{"location":"api_core/#pysymmetry.Dg_Linear_Transformation","title":"<code>pysymmetry.Dg_Linear_Transformation</code>","text":"<p>               Bases: <code>VectorSpaceMorphism</code></p>"},{"location":"api_core/#pysymmetry.Dg_Linear_Transformation.character","title":"<code>character()</code>","text":"<p>Return the character of a representation defined over an arbitrary group G.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- representation; a representation defined over an arbitrary group G.</li> </ul> <p>OUTPUT: The character of self. </p> <p>EXAMPLES:</p> <p>We define the representation by permutation on the cyclic group of 4 elements and calculate its characters ::</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(4)) \nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices); rep\nsage: g = G.an_element()\nsage: rep(g).character()\n0\nsage: [rep(g).character() for g in G]\n[4, 0, 0, 0]\n</code></pre> <p>We define one representation on the group of symmetries of regular hexagon and calculate the character of each element in the group ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: matrices = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])];\nsage: rep = representation(generators, matrices)\nsage: G = rep.domain()\nsage: [ [g,rep(g).character()] for g in G]\n[[(), 2],\n [(1,5,3)(2,6,4), -1],\n [(1,3,5)(2,4,6), -1],\n [(1,6,5,4,3,2), 1],\n [(1,4)(2,5)(3,6), -2],\n [(1,2,3,4,5,6), 1],\n [(2,6)(3,5), 0],\n [(1,5)(2,4), 0],\n [(1,3)(4,6), 0],\n [(1,6)(2,5)(3,4), 0],\n [(1,4)(2,3)(5,6), 0],\n [(1,2)(3,6)(4,5), 0]]\n</code></pre> <p>We define the regular representation over the symmetric group of 4 simbols and calculate its characters ::</p> <pre><code>sage: H = SymmetricGroup(4)\nsage: G = FiniteGroup(H);\nsage: reg = G.regular_representation();\nsage: [ [g,reg(g).character()] for g in G]\n[[(), 24],\n [(1,4)(2,3), 0],\n [(1,2)(3,4), 0],\n [(1,3)(2,4), 0],\n [(2,4,3), 0],\n [(1,4,2), 0],\n [(1,2,3), 0],\n [(1,3,4), 0],\n [(2,3,4), 0],\n [(1,4,3), 0],\n [(1,2,4), 0],\n [(1,3,2), 0],\n [(3,4), 0],\n [(1,4,2,3), 0],\n [(1,2), 0],\n [(1,3,2,4), 0],\n [(2,4), 0],\n [(1,4,3,2), 0],\n [(1,2,3,4), 0],\n [(1,3), 0],\n [(2,3), 0],\n [(1,4), 0],\n [(1,2,4,3), 0],\n [(1,3,4,2), 0]]\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#core-module-functions","title":"Core Module Functions","text":""},{"location":"api_core/#pysymmetry.representation","title":"<code>pysymmetry.representation(generators, matrices, field=QQbar)</code>","text":"<p>Create a representation of an arbitrary group G.</p> <p>INPUT:</p> <ul> <li> <p><code>generators</code> -- list; generators of the group G.</p> </li> <li> <p><code>matrices</code> -- list; generators images in the same sequence of generators.</p> </li> <li> <p><code>field</code> -- Sage ring (default: <code>QQbar</code>); Field of the subjacent representation vector space. Faster computations using the fields <code>QQbar</code> or <code>AA</code>.</p> </li> </ul> <p>OUTPUT: Mapping of the group generated by <code>generators</code> to the group of matrices generated by <code>matrices</code>.</p> <p>EXAMPLES:</p> <p>This example illustrates the representation by permutation defined on the group of symmetries of the equilateral triangle ::</p> <pre><code>sage: G = DihedralGroup(3) \nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: rep\nMap: \n From: Permutation FiniteGroup with generators [(1,2,3), (1,3)] \n To: Matrix group over Algebraic Field with 2 generators (\n[0 1 0]  [0 0 1]\n[0 0 1]  [0 1 0]\n[1 0 0], [1 0 0]\n).\n</code></pre> <p>Matrix associated to an element g of G ::</p> <pre><code>sage: g = G.an_element()\nsage: rep(g).matrix()\n[0 1 0]\n[1 0 0]\n[0 0 1]\n</code></pre> <p>We define the generators of the group of symmetries of an regular hexagon, and the correspondent matrices of symmetry (a rotation through an angle \\(\\pi/3\\), and a reflexion across the \\(x\\) axis in the cartesian plane) ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: matrices = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])]\nsage: rep = representation(generators, matrices)\nsage: rep(\"(1,2,3,4,5,6)\")\nLinear transformation associated with element g=(1,2,3,4,5,6), represented by the non-singular matrix:\n[                1/2 -0.866025403784439?]\n[ 0.866025403784439?                 1/2]\nRepresentation space: Vector space of dimension 2 over Algebraic Field\n\nsage: rep(\"(1,4)(2,3)(5,6)\")\nLinear transformation associated with element g=(1,4)(2,3)(5,6), represented by the non-singular matrix:\n[-1  0]\n[ 0  1]\nRepresentation space: Vector space of dimension 2 over Algebraic Field\n\nsage: (rep.domain()).is_isomorphic(DihedralGroup(6))\nTrue\n</code></pre> <p>Next we define the same representation where the field is choosed to be SR ::</p> <pre><code>sage: rep = representation(generators, matrices, field=SR)\nsage: rep(\"(1,2,3,4,5,6)\")\nLinear transformation associated with element g=(1,2,3,4,5,6), represented by the non-singular matrix:\n[         1/2 -1/2*sqrt(3)]\n[ 1/2*sqrt(3)          1/2]\nRepresentation space: Vector space of dimension 2 over Symbolic Ring\n</code></pre> <p>We choose a random element of the group and show its matrix ::</p> <pre><code>sage: G = FiniteGroup(generators)\nsage: g = G.an_element()\nsage: rep(g)\nLinear transformation associated with element g=(1,3)(4,6), represented by the non-singular matrix:\n[        -1/2 -1/2*sqrt(3)]\n[-1/2*sqrt(3)          1/2]\nRepresentation space: Vector space of dimension 2 over Symbolic Ring\n</code></pre> <p>The identity and inverse properties of the representation are illustred ::</p> <pre><code>sage: e = G.identity()\nsage: rep(e)\nLinear transformation associated with element g=(), represented by the non-singular matrix:\n[1 0]\n[0 1]\nRepresentation space: Vector space of dimension 2 over Symbolic Ring\nsage: [rep(g.inverse())==rep(g).inverse() for g in G]\n[True, True, True, True, True, True, True, True, True, True, True, True]\n</code></pre> <p>It is an error to choose the group element as a tuple ::</p> <pre><code>sage: rep((1,4)(2,3)(5,6))\nTypeError: Traceback (most recent call last):\n...\nTypeError: 'tuple' object is not callable\n\nsage: rep((1,2,3,4,5,6))\nTypeError: Traceback (most recent call last):\n...\nTypeError:  'tuple' object is not callable\n</code></pre> <p>The argument can be a string or a list. Be aware that '(1,2,3,4,5,6)' is the usual notation of cycle, while [1,2,3,4,5,6] lists the images of the permutation ::</p> <pre><code>sage: rep(\"(1,2,3,4,5,6)\")\nLinear transformation associated with element g=(1,2,3,4,5,6), represented by the non-singular matrix:\n[         1/2 -1/2*sqrt(3)]\n[ 1/2*sqrt(3)          1/2]\nRepresentation space: Vector space of dimension 2 over Symbolic Ring\n\nsage: rep([1,2,3,4,5,6])\nLinear transformation associated with element g=(), represented by the non-singular matrix:\n[1 0]\n[0 1]\nRepresentation space: Vector space of dimension 2 over Symbolic Ring\n\nsage: rep([2,3,4,5,6,1])\nLinear transformation associated with element g=(1,2,3,4,5,6), represented by the non-singular matrix:\n[         1/2 -1/2*sqrt(3)]\n[ 1/2*sqrt(3)          1/2]\nRepresentation space: Vector space of dimension 2 over Symbolic Ring\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_core/#pysymmetry.get_block","title":"<code>pysymmetry.get_block(columm_base, matrix_equiv)</code>","text":"<p>Return the matricial representation of matrix_equiv when restricted to the subspace whose basis is columm_base.</p> <p>INPUT:</p> <ul> <li><code>columm_base</code> -- matrix ; a matrix(with full rank) whose columns are part of symmetry adapted basis.</li> <li><code>matrix_equiv</code> -- matrix ; a matrix an equivariant operator.</li> </ul> <p>OUTPUT: A matrix representing the restriction of matrix_equiv to the subespaces given by column_base.</p> <p>EXAMPLES:</p> <p>We define the representation by permutation on the cyclic group of four elements and calculates the blocks of an equivariant operator under this representation  ::</p> <pre><code>sage: G = FiniteGroup(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: subspaces = G.base_change_eigenvalue_reduction_new(rep) #The Invariant Subspaces\nsage: A = matrix.circulant([1,2,3,4]); #An equivariant Operator \nsage: rep.is_equivariant_to(A)\nTrue\nsage: [get_block(k[0],A) for k in subspaces[0]] # The block decomposition of the equivariant operator\n[[10], [-2], [-2 - 2*I], [-2 + 2*I]]\n</code></pre> <p>We define a representation on a permutation group, and calculates the blocks(no repetition) of an equivariant operator  ::</p> <pre><code>sage: G = FiniteGroup(['(2,4)(3,7)(6,8)', '(1,3)(4,6)(7,9)'])\nsage: gens = G.gens()\nsage: matrices = [g.matrix() for g in gens]\nsage: rep = representation(gens, matrices)\nsage: operator = matrix([[ 4, -1, -0, -1, -0, -0, -0, -0, -0],\n                        [-1,  4, -1, -0, -1, -0, -0, -0, -0],\n                        [-0, -1,  4, -0, -0, -1, -0, -0, -0],\n                        [-1, -0, -0,  4, -1, -0, -1, -0, -0],\n                        [-0, -1, -0, -1,  4, -1, -0, -1, -0],\n                        [-0, -0, -1, -0, -1,  4, -0, -0, -1],\n                        [-0, -0, -0, -1, -0, -0,  4, -1, -0],\n                        [-0, -0, -0, -0, -1, -0, -1,  4, -1],\n                        [-0, -0, -0, -0, -0, -1, -0, -1,  4]])  #An equivariant Operator \nsage: rep.is_equivariant_to(operator)\nTrue\nsage: subspaces = G.base_change_eigenvalue_reduction_new(rep) #The Invariant Subspaces\nsage: [get_block(k[0],operator) for k in subspaces[0]] # The block decomposition of the equivariant operator\n[\n[ 4 -2  0]                   \n[-2  4 -4]            [ 4 -1]\n[ 0 -1  4], [4], [4], [-2  4]\n]\n\n#NOTE: It is worth to note, in this case, that the two equal blocks [4], comes from inequivalent subrepresentations.\nIn this case, the theory has not way to foresee that.\n</code></pre> <p>We define the regular representation(reg) over the symmetric group of 3 simbols and calculate the blocks of an equivariant operator without repetition ::</p> <pre><code>sage: H = SymmetricGroup(3)\nsage: G = FiniteGroup(H);\nsage: reg = G.regular_representation();\nsage: Id = matrix.identity(reg.degree()); # Identity matrix\nsage: reg.is_equivariant_to(Id)\nTrue\nsage: subspaces = G.base_change_eigenvalue_reduction_new(reg) #The Invariant Subspaces\nsage: [get_block(k[0],Id) for k in subspaces[0]] # The block decomposition of the equivariant operator\n[\n[1], [1],\n\n[1.000000000000000? + 0.?e-18*I                              0]\n[                             0 1.000000000000000? + 0.?e-18*I]\n]\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. FiniteGroup theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul>"},{"location":"api_parallel/","title":"API: Parallel Module (parallel)","text":"<p>Tools for parallelizing calculations.</p>"},{"location":"api_parallel/#pysymmetry.parallel.pmap","title":"<code>pysymmetry.parallel.pmap(f, X, nprocs=cpu_count())</code>","text":"<p>Parallel map over iterable X using up to nprocs worker processes.</p> <p>INPUT: - f -- callable applied to each element of X (must be picklable) - X -- iterable of inputs - nprocs -- number of processes (default: cpu_count())</p> <p>OUTPUT: - list with f(x) for x in X, preserving the original order</p> <p>EXAMPLES::</p> <pre><code>sage: from pysymmetry.parallel import pmap\nsage: pmap(lambda t: t*t, [0,1,2,3], nprocs=2)\n[0, 1, 4, 9]\n</code></pre>"},{"location":"api_parallel/#pysymmetry.parallel.pmap_reduce","title":"<code>pysymmetry.parallel.pmap_reduce(f, X, fun=add, nprocs=cpu_count())</code>","text":"<p>Parallel map followed by reduction across worker-local partial results.</p> <p>INPUT: - f -- callable applied to each element of X (must be picklable) - X -- iterable of inputs - fun -- associative binary function used to combine partial results          (default: operator.add) - nprocs -- number of processes (default: cpu_count())</p> <p>OUTPUT: - single value equal to fun(f(x0), fun(f(x1), ...)) in unspecified tree order</p> <p>EXAMPLES::</p> <pre><code>sage: from pysymmetry.parallel import pmap_reduce\nsage: # Sum of squares of 0..4\nsage: pmap_reduce(lambda t: t*t, range(5), fun=lambda a,b: a+b, nprocs=2)\n30\n</code></pre>"},{"location":"api_pde/","title":"API: Numerical Module (pde)","text":"<p>Optimized functions and classes for numerical calculations and solving PDEs.</p>"},{"location":"api_pde/#pysymmetry.pde.nfinitegroup","title":"<code>pysymmetry.pde.nfinitegroup = nFiniteGroup</code>  <code>module-attribute</code>","text":""},{"location":"api_pde/#numerical-functions","title":"Numerical Functions","text":""},{"location":"api_pde/#pysymmetry.pde.ninner_product","title":"<code>pysymmetry.pde.ninner_product(G, left, right)</code>","text":"<p>Inner product of characters using conjugacy class aggregation.</p> <p>INPUT: - G -- group (nFiniteGroup or Sage permutation group) - left -- dictionary representation (g -&gt; sparse matrix) for the left rep - right -- dictionary representation (g -&gt; sparse matrix) for the right rep</p> <p>OUTPUT: - int -- the character inner product  <p>EXAMPLES::</p> <pre><code>sage: # For a regular representation 'reg', &lt;reg, reg&gt; equals |G|\nsage: # ninner_product(G, reg, reg)\n</code></pre>"},{"location":"api_pde/#pysymmetry.pde.ndegree","title":"<code>pysymmetry.pde.ndegree(G, rep)</code>","text":"<p>Degree (matrix size) of a numerical representation.</p> <p>INPUT: - G -- group - rep -- dictionary representation (g -&gt; sparse matrix)</p> <p>OUTPUT: - int -- the dimension of the representation space</p>"},{"location":"api_pde/#pysymmetry.pde.nget_block","title":"<code>pysymmetry.pde.nget_block(columm_base, matrix_equiv)</code>","text":"<p>Compute the block of an equivariant matrix in a given column-space basis.</p> <p>Given columns B spanning an isotypic component and an equivariant matrix A, returns P * A * B, where P is the pseudoinverse of the dense array of B.</p> <p>INPUT: - columm_base -- SciPy sparse matrix (columns are basis vectors) - matrix_equiv -- SciPy sparse matrix A that commutes with the group action</p> <p>OUTPUT: - gcsr_matrix -- the block of A restricted to span(B)</p> <p>NOTE: - This uses a numerical pseudoinverse (NumPy). For exact arithmetic, adapt   to Sage exact linear algebra if needed.</p>"},{"location":"api_util/","title":"API: Utilities Module (util)","text":"<p>Helper functions for common tasks.</p>"},{"location":"api_util/#pysymmetry.util.laplacian1d","title":"<code>pysymmetry.util.laplacian1d(n, h=1)</code>","text":"<p>Return the 1D three-point Laplacian on a line of length n (CSC sparse).</p> <p>The stencil is (1, -2, 1) scaled by 1/h^2.</p> <p>INPUT: - n -- positive integer, number of grid points - h -- grid spacing (default: 1)</p> <p>OUTPUT: - SciPy csc_matrix of shape (n, n)</p> <p>EXAMPLES::</p> <pre><code>sage: from pysymmetry.util import laplacian1d\nsage: A = laplacian1d(4)\nsage: A.get_shape()\n(4, 4)\n</code></pre>"},{"location":"api_util/#pysymmetry.util.laplacian2d","title":"<code>pysymmetry.util.laplacian2d(n)</code>","text":"<p>Return the 2D five-point Laplacian on an n x n grid (CSC sparse).</p> <p>Uses a block-diagonal structure with off-diagonal blocks to couple vertical neighbors; diagonal blocks contain the standard 1D stencil.</p> <p>INPUT: - n -- positive integer, grid side length</p> <p>OUTPUT: - SciPy csc_matrix of shape \\((n^2, n^2)\\) representing -\u0394 on the grid</p> <p>EXAMPLES::</p> <pre><code>sage: from pysymmetry.util import laplacian2d\nsage: A = laplacian2d(3)\nsage: A.get_shape()\n(9, 9)\n</code></pre>"},{"location":"api_util/#pysymmetry.util.advection_diffusion_2d","title":"<code>pysymmetry.util.advection_diffusion_2d(n, D=1.0, vx=1.0)</code>","text":"<p>Build the 2D advection-diffusion operator on an n x n grid (CSC sparse).</p> <p>The operator is A = D(-\u0394) - vxDx, where -\u0394 is the 2D five-point Laplacian and Dx is a centered first-difference in the x-direction.</p> <p>INPUT: - n -- positive integer, grid side length - D -- diffusion coefficient (default: 1.0) - vx -- advection velocity in x (default: 1.0)</p> <p>OUTPUT: - SciPy csc_matrix of shape (n^2, n^2)</p> <p>EXAMPLES::</p> <pre><code>sage: from pysymmetry.util import advection_diffusion_2d\nsage: A = advection_diffusion_2d(3)\nsage: A.get_shape()\n(9, 9)\n</code></pre>"},{"location":"api_util/#pysymmetry.util.to_csr","title":"<code>pysymmetry.util.to_csr(m)</code>","text":"<p>Convert a Sage sparse matrix to a SciPy CSC sparse matrix.</p> <p>INPUT: - m -- a Sage matrix (typically sparse) with a .dict() method of nonzeros</p> <p>OUTPUT: - SciPy csc_matrix with the same nonzero pattern and values</p> <p>EXAMPLES::</p> <pre><code>sage: from sage.all import matrix\nsage: from pysymmetry.util import to_csr\nsage: M = matrix({(0,0): 2, (1,2): -1})\nsage: S = to_csr(M)\nsage: S.get_shape()\n(2, 3)\n</code></pre>"},{"location":"api_util/#pysymmetry.util.to_csc","title":"<code>pysymmetry.util.to_csc(m)</code>","text":"<p>Convert a Sage sparse matrix to a SciPy CSC sparse matrix.</p> <p>INPUT: - m -- a Sage matrix (typically sparse) with a .dict() method of nonzeros</p> <p>OUTPUT: - SciPy csc_matrix with the same nonzero pattern and values</p> <p>EXAMPLES::</p> <pre><code>sage: from sage.all import matrix\nsage: from pysymmetry.util import to_csc\nsage: M = matrix({(0,1): 3, (2,0): -5})\nsage: S = to_csc(M)\nsage: S.get_shape()\n(3, 2)\n</code></pre>"},{"location":"api_util/#pysymmetry.util.view","title":"<code>pysymmetry.util.view(matrix, latex=True)</code>","text":"<p>Pretty-print a Sage matrix, optionally using LaTeX rendering.</p> <p>Attempts to convert symbolic entries to radical expressions for readability. If latex=True, shows the matrix via Sage's show().</p> <p>INPUT: - matrix -- a Sage matrix - latex -- bool (default: True); if True, render with show()</p> <p>OUTPUT: - The displayed object (if latex=True) or the transformed matrix</p> <p>EXAMPLES::</p> <pre><code>sage: from sage.all import matrix, sqrt\nsage: from pysymmetry.util import view\nsage: M = matrix([[1, sqrt(2)], [0, 1]])\nsage: view(M, latex=False)  # returns a matrix with radical_expression applied\n[1 sqrt(2)]\n[0       1]\n</code></pre>"},{"location":"contributing/","title":"Contributing to PySymmetry","text":"<p>We welcome contributions from the community! Whether it's reporting a bug, proposing a new feature, or submitting code, your help is valuable.</p>"},{"location":"contributing/#bug-reports-and-feature-requests","title":"Bug Reports and Feature Requests","text":"<p>Please use the Issues tab on our GitHub repository to report bugs or suggest new features. Provide as much detail as possible, including steps to reproduce the bug.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<p>To contribute code, you'll need to set up a local development environment.</p> <ol> <li>Fork the repository on GitHub.</li> <li>Clone your fork locally:     <pre><code>git clone https://github.com/ldsufrpe/pysymmetry.git\ncd pysymmetry\n</code></pre></li> <li>Set up SageMath: Ensure you have a working SageMath environment as described in the installation guide.</li> </ol>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<p>Before submitting a contribution, please ensure that all tests pass. The tests for this project are located in <code>pysymmetry/test.py</code>.</p> <p>You can run the test suite using the following command from the project's root directory:</p> <p><code>bash sage -t pysymmetry/test.py -v</code></p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Create a new branch for your feature or bug fix.</li> <li>Make your changes and ensure all tests pass.</li> <li>Add docstrings for any new functions or classes.</li> <li>Submit a pull request to the <code>main</code> branch of the original repository.</li> </ol>"},{"location":"installation/","title":"Installation Guide","text":"<p>To use <code>PySymmetry</code>, you must have a working installation of SageMath. This guide provides detailed steps for setting up the environment.</p>"},{"location":"installation/#step-1-install-sagemath","title":"Step 1: Install SageMath","text":"<p>SageMath is a free, open-source mathematics software system that <code>PySymmetry</code> relies on. The installation process varies depending on your operating system.</p>"},{"location":"installation/#windows","title":"Windows","text":"<p>The recommended method for Windows is to use the Windows Subsystem for Linux (WSL).</p> <ol> <li> <p>Enable WSL: Open PowerShell as an administrator and run:     <pre><code>wsl --install\n</code></pre>     This command will enable the necessary features, download the latest Linux kernel, and install a Linux distribution (Ubuntu by default).</p> </li> <li> <p>Set up your Linux environment: Once installed, launch your Linux distribution (e.g., Ubuntu) from the Start Menu and follow the on-screen instructions to create a user account and password.</p> </li> <li> <p>Install SageMath: Inside your Linux terminal, you can install SageMath using its official binaries or from a package manager.</p> </li> </ol>"},{"location":"installation/#macos-linux","title":"macOS &amp; Linux","text":"<p>For macOS and Linux, you can use pre-built binaries, which is the easiest method.</p> <ol> <li>Download SageMath: Visit the official SageMath download page and download the binary for your operating system.</li> <li>Extract the files: Unpack the downloaded archive to a location of your choice.</li> <li>Run SageMath: You can run SageMath directly from the extracted folder.</li> </ol> <p>For the most up-to-date and detailed instructions, always refer to the Official SageMath Installation Guide.</p>"},{"location":"installation/#step-2-install-pysymmetry","title":"Step 2: Install PySymmetry","text":"<p>Once SageMath is installed and working, you can set up <code>PySymmetry</code>.</p> <ol> <li> <p>Clone the Repository: Open a terminal and run the following command to clone the project from GitHub:     <pre><code>git clone https://github.com/ldsufrpe/pysymmetry.git\n</code></pre></p> </li> <li> <p>Navigate to the Directory:     <pre><code>cd pysymmetry\n</code></pre>     The library is now ready to be used within the SageMath environment.</p> </li> </ol>"},{"location":"installation/#step-3-launch-and-use","title":"Step 3: Launch and Use","text":"<p>The best way to use <code>PySymmetry</code> is through a Jupyter Notebook within the SageMath environment.</p> <ol> <li>Start Jupyter: In your terminal, from the <code>pysymmetry</code> project directory, run:     <pre><code>sage -n jupyter\n</code></pre></li> <li>Create or Open a Notebook: This command will open a new tab in your browser. You can create a new notebook (be sure to select the \"SageMath\" kernel) or open one of the examples from the <code>Examples/</code> directory.</li> </ol>"},{"location":"tutorial/","title":"Tutorials","text":"<p>This page provides step-by-step tutorials for solving common problems using <code>PySymmetry</code>.</p>"},{"location":"tutorial/#example-1-a-d4-symmetric-system","title":"Example 1: A D4-Symmetric System","text":"<p>This tutorial demonstrates how to block-diagonalize any matrix that is equivariant under a group's action. We will use the dihedral group \\(D_4\\), which represents the symmetries of a square.</p>"},{"location":"tutorial/#background","title":"Background","text":"<p>Imagine a system with 4 points arranged in a square. Any operator on this system that respects the square's symmetries (rotations and reflections) will have a matrix that commutes with the matrix representation of the \\(D_4\\) group. Such a matrix is called \"G-equivariant,\" and <code>PySymmetry</code> can simplify it.</p>"},{"location":"tutorial/#implementation-with-pysymmetry","title":"Implementation with <code>PySymmetry</code>","text":"<pre><code>from pysymmetry import FiniteGroup, representation\nfrom sage.all import matrix, QQ\n\n# Step 1: Define the D4 group using its generators\nrotation = \"(1,2,3,4)\"\nreflection = \"(1,3)\"\nG = FiniteGroup([rotation, reflection])\n\n# Step 2: Define the Natural Permutation Representation\nphi = G.natural_representation()\n\n# Step 3: Define a G-Equivariant Matrix M\na, b, c = 10, 2, 1\nM = matrix(QQ, [[a, b, c, b],\n                [b, a, b, c],\n                [c, b, a, b],\n                [b, c, b, a]])\n\n# Step 4: Compute the Symmetry-Adapted Basis\nP = G.base_change_matrix(phi)\n\n# Step 5: Perform the Block-Diagonalization\nM_block_diagonal = P.inverse() * M * P\n\nprint(\"Original Matrix M:\")\nshow(M)\nprint(\"\\nSymmetry-Adapted Basis P:\")\nshow(P)\nprint(\"\\nBlock-Diagonal Matrix P^{-1}MP:\")\nshow(M_block_diagonal)\n</code></pre>"},{"location":"tutorial/#results","title":"Results","text":"<p>The output shows that the original matrix <code>M</code> is transformed into a block-diagonal matrix containing two 1x1 blocks and one 2x2 block. This decomposition simplifies further analysis, such as finding eigenvalues, which can now be done on the smaller blocks independently.</p>"},{"location":"tutorial/#example-2-molecular-vibrations-in-chemistry-gf-method","title":"Example 2: Molecular Vibrations in Chemistry (GF Method)","text":"<p>This tutorial showcases how <code>PySymmetry</code> can be applied to a real-world problem in chemistry: analyzing the vibrational frequencies of a molecule using the GF method.</p>"},{"location":"tutorial/#background-the-gf-method","title":"Background: The GF Method","text":"<p>The GF method is a classical approach to studying molecular vibrations. The core task is to solve the secular equation \\((\\mathbf{FG}-\\lambda I) = 0\\), where:</p> <ul> <li>F is the force-constant matrix (from potential energy).</li> <li>G is the inverse kinetic energy matrix (from atomic masses and geometry).</li> </ul> <p>When a molecule like water (\\(H_2O\\)) has symmetry (in this case, the \\(C_{2v}\\) point group), both F and G commute with the symmetry operations. This allows us to use <code>PySymmetry</code> to find a basis that block-diagonalizes the FG matrix, dramatically simplifying the eigenvalue problem.</p>"},{"location":"tutorial/#implementation-with-pysymmetry_1","title":"Implementation with <code>PySymmetry</code>","text":"<pre><code>from pysymmetry import FiniteGroup, representation\nfrom sage.all import matrix, var, show\n\n# Step 1: Define the C2v Group as a Permutation Group\ngenerators = [\"(1,2)\", \"(1)(2)(3)\"]\nC2v = FiniteGroup(generators)\ngens = C2v.gens()\n\n# Step 2: Define the Permutation Representation\nC2_matrix = matrix(3, 3, [[0, 1, 0], [1, 0, 0], [0, 0, 1]])\nE_matrix = matrix(3, 3, [[1, 0, 0], [0, 1, 0], [0, 0, 1]])\nrep = representation(gens, [C2_matrix, E_matrix])\n\n# Step 3: Find the Symmetry-Adapted Basis\nbeta = C2v.base_change_matrix(rep)\nprint(\"Symmetry-Adapted Basis (beta):\")\nshow(beta)\n\n# Step 4: Define Symbolic F and G Matrices\nf11, f12, f33 = var('f11, f12, f33')\ng11, g12, g13, g33 = var('g11, g12, g13, g33')\n\nF_H2O = matrix(3, 3, [[f11, f12, 0], [f12, f11, 0], [0, 0, f33]])\nG_H2O = matrix(3, 3, [[g11, g12, g13], [g12, g11, g13], [g13, g13, g33]])\n\n# Step 5: Perform the Block-Diagonalization\nFG_original = F_H2O * G_H2O\nFG_block_diagonal = beta.inverse() * FG_original * beta\n\nprint(\"\\nBlock-Diagonalized FG Matrix (beta^-1 * FG * beta):\")\nshow(FG_block_diagonal)\n</code></pre>"},{"location":"tutorial/#results_1","title":"Results","text":"<p>By transforming to the basis <code>beta</code>, the <code>FG</code> matrix is converted into a block-diagonal form, separating the problem into a 2x2 block and a 1x1 block. This simplifies the calculation of its eigenvalues, which correspond to the molecule's vibrational frequencies.</p>"},{"location":"tutorial/#exemplo-3-exploiting-symmetry-to-solve-a-physics-problem","title":"Exemplo 3: Exploiting Symmetry to Solve a Physics Problem","text":"<p>This tutorial demonstrates a core use case for <code>PySymmetry</code>: simplifying a common eigenvalue problem by exploiting the underlying symmetry of a physical system. We will find the eigenvalues of a 1D Laplacian operator, a task frequently encountered in physics and engineering.</p> <p>The central idea is that the reflection symmetry of the 1D system allows us to block-diagonalize the Laplacian matrix. This breaks a large problem into smaller, independent ones, making the eigenvalue calculation significantly more efficient.</p>"},{"location":"tutorial/#step-1-setup-and-problem-definition","title":"Step 1: Setup and Problem Definition","text":"<p>First, we import the necessary libraries and define our operator. We will use a helper function from the <code>util</code> module to create the Laplacian matrix for a system with 100 points.</p> <p><pre><code># Import necessary components\nfrom pysymmetry import FiniteGroup\nfrom pysymmetry.util import laplacian1d, get_block\nfrom sage.all import *\nimport numpy as np\n</code></pre> Define the size of our system and create the Laplacian matrix</p> <pre><code>n = 100\nM = laplacian1d(n)\n</code></pre>"},{"location":"tutorial/#step-2-define-the-symmetry-group","title":"Step 2: Define the Symmetry Group","text":"<p>A 1D system discretized into <code>n</code> points has a reflection symmetry about its center. This symmetry can be described by a group with a single operation: swapping point <code>j</code> with point <code>n - j + 1</code>. We create this group using its permutation generator.</p> <pre><code># Define the generator for the reflection group\ndef generators1d(n):\n    reflection_str = ''\n    # Use integer division for compatibility\n    for j in range(1, (n // 2 + 1)):\n        reflection_str += str((j, n - j + 1))\n    return [reflection_str]\n</code></pre> <p>Create the FiniteGroup object <pre><code>G = FiniteGroup(generators1d(n))\nprint(f\"Symmetry group created: {G}\")\n</code></pre></p>"},{"location":"tutorial/#step-3-compute-the-symmetry-adapted-basis","title":"Step 3: Compute the Symmetry-Adapted Basis","text":"<p>Now, we use <code>PySymmetry</code> to find the basis that respects the group's structure. This \"symmetry-adapted basis\" is the key to block-diagonalizing our matrix. We start by computing the natural representation of the group.</p> <pre><code># Get the natural (permutation) representation of the group\nrep = G.natural_representation()\n\n# Compute the basis that reduces the representation\nbase_info, _ = G.base_change_eigenvalue_reduction_new(rep)\n</code></pre>"},{"location":"tutorial/#step-4-decompose-the-matrix-and-find-eigenvalues","title":"Step 4: Decompose the Matrix and Find Eigenvalues","text":"<p>With the symmetry-adapted basis, we can project the original large matrix <code>M</code> into smaller, independent blocks. The eigenvalues of these small blocks are the same as the eigenvalues of the original matrix, but are much easier to compute.</p> <p>Use get_block to project M onto the subspaces defined by our new basis: <pre><code>blocks = [get_block(info[0], M) for info in base_info]\n</code></pre></p> <p>Calculate eigenvalues for each small block and then combine them <pre><code>eigenvalues_from_blocks = sorted(np.concatenate(\n    [np.linalg.eigvals(b.toarray()) for b in blocks]\n))\n\nprint(f\"Successfully found {len(eigenvalues_from_blocks)} eigenvalues from the decomposed blocks.\")\n</code></pre></p> <p>This completes the process. The <code>eigenvalues_from_blocks</code> list contains all the eigenvalues of the full <code>M</code> matrix. By using symmetry, we avoided direct computation on the large matrix and instead solved the problem on smaller, simpler ones.</p>"}]}
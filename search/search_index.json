{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem-vindo \u00e0 documenta\u00e7\u00e3o do pysymmetry","text":"<p><code>pysymmetry</code> \u00e9 uma biblioteca para... (descreva seu projeto aqui).</p>"},{"location":"api/","title":"Refer\u00eancia da API","text":"<p>Esta \u00e9 a refer\u00eancia autom\u00e1tica da API gerada a partir do c\u00f3digo-fonte.</p>"},{"location":"api/#modulo-pysymmetry","title":"M\u00f3dulo <code>pysymmetry</code>","text":"<p>               Bases: <code>PermutationGroup_generic</code></p> Source code in <code>pysymmetry/pysymmetry.py</code> <pre><code>class Group(PermutationGroup_generic):\n    def __init__(self, per_group, field=QQbar, matrix=False):\n\n        if isinstance(per_group, PermutationGroup_generic):\n            per_group = per_group.gens()\n\n        if matrix:\n\n            check_matrix = all([isinstance(m, (Matrix_integer_dense, Matrix_integer_sparse)) for m in per_group])\n\n            if check_matrix:\n\n                per_group = MatrixGroup(per_group).as_permutation_group().gens()\n\n            else:\n                raise TypeError('no matrices')\n\n        super().__init__(per_group,\n                         gap_group=None,\n                         domain=None,\n                         canonicalize=True,\n                         category=None)\n\n        self.field = field\n\n    def _hom_(self, n):\n        return Hom(self.field**n, self.field**n)    \n\n    def _regular_(self, g):\n        elements = self.list()\n        new_elements = [g*element for element in elements]\n        index = [elements.index(element) for element in new_elements]\n        base = matrix.identity(self.order())[:, index]\n        #base = base  # sage matrix\n        H = self._hom_(self.order())        \n        return Dg_Linear_Transformation(H, base, g)  # class Representation\n\n    def regular_representation(self):\n        r\"\"\"\n        Return the regular representation defined over the group.\n\n        INPUT:\n\n        - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n\n        OUTPUT: The regular representation defined over the Group given by self. \n\n\n        EXAMPLES:\n\n        We define the regular representation over the cyclic group of 4 elements ::\n\n            sage: G = Group(CyclicPermutationGroup(4)) \n            sage: reg = G.regular_representation()\n            sage: [reg(g) for g in G]\n            [Linear transformation associated with element g=(), represented by the non-singular matrix:\n             [1 0 0 0]\n             [0 1 0 0]\n             [0 0 1 0]\n             [0 0 0 1]\n             Representation space: Vector space of dimension 4 over Algebraic Field\n             ,\n             Linear transformation associated with element g=(1,2,3,4), represented by the non-singular matrix:\n             [0 0 0 1]\n             [1 0 0 0]\n             [0 1 0 0]\n             [0 0 1 0]\n             Representation space: Vector space of dimension 4 over Algebraic Field\n             ,\n             Linear transformation associated with element g=(1,3)(2,4), represented by the non-singular matrix:\n             [0 0 1 0]\n             [0 0 0 1]\n             [1 0 0 0]\n             [0 1 0 0]\n             Representation space: Vector space of dimension 4 over Algebraic Field\n             ,\n             Linear transformation associated with element g=(1,4,3,2), represented by the non-singular matrix:\n             [0 1 0 0]\n             [0 0 1 0]\n             [0 0 0 1]\n             [1 0 0 0]\n             Representation space: Vector space of dimension 4 over Algebraic Field\n             ]\n\n        We define the group of symmetries of regular hexagon and the regular representation over this group ::\n\n            sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\n            sage: G = Group(generators)\n            sage: reg = G.regular_representation()\n            sage: g = G.an_element()\n            sage: reg(g)\n            Linear transformation associated with element g=(1,3)(4,6), represented by the non-singular matrix:\n            [0 0 0 0 0 0 0 0 1 0 0 0]\n            [0 0 0 0 0 0 1 0 0 0 0 0]\n            [0 0 0 0 0 0 0 1 0 0 0 0]\n            [0 0 0 0 0 0 0 0 0 0 0 1]\n            [0 0 0 0 0 0 0 0 0 1 0 0]\n            [0 0 0 0 0 0 0 0 0 0 1 0]\n            [0 1 0 0 0 0 0 0 0 0 0 0]\n            [0 0 1 0 0 0 0 0 0 0 0 0]\n            [1 0 0 0 0 0 0 0 0 0 0 0]\n            [0 0 0 0 1 0 0 0 0 0 0 0]\n            [0 0 0 0 0 1 0 0 0 0 0 0]\n            [0 0 0 1 0 0 0 0 0 0 0 0]\n            Representation space: Vector space of dimension 12 over Algebraic Field\n\n        We define the regular representation over the symmetric group of 4 simbols ::\n\n            sage: H = SymmetricGroup(4)\n            sage: G = Group(H);\n            sage: reg = G.regular_representation();\n            sage: g = G.an_element()\n            sage: reg(g)\n            Linear transformation associated with element g=(1,3,4), represented by the non-singular matrix:\n            24 x 24 dense matrix over Algebraic Field\n            Representation space: Vector space of dimension 24 over Algebraic Field\n\n\n        REFERENCES:\n\n        For more information, see the following references:\n\n        - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n        - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n        \"\"\"                \n\n\n        # usei metodos do orderpy pra deixar os calculos mais rapidos\n        #NOTA: precisa verificar se g esta em Group\n        matrices = [self._regular_(g).matrix() for g in self.gens()]\n        M = MatrixGroup(matrices)\n        return MapRepresentation(Hom(self, M), self._regular_)\n\n    def irreducible_representations(self, show_table=True): ##Nota: Como documentar saida com o True\n        r\"\"\"\n        Return the number n of irreducible representations of self and the irreducibles representations.\n\n\n        INPUT:\n\n        - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n        - ``show_table`` -- a boolean (default: `True`) ; shows a table of each irreducible representation applied at the generators of self.\n\n        OUTPUT: If show_table=True; return number of irreducible representions and irreducible representions themselves.\n                If show_table=False; return the irreducible representions themselves. \n\n\n        EXAMPLES:\n\n        We define the symmetric group of 4 simbols and calculate its irreducible representations ::\n\n            sage: G = Group(SymmetricGroup(4));\n            sage: n, irr = G.irreducible_representations(False) #Irreducible representations\n            sage: n\n            5\n            sage: irr(0)\n            Map: \n             From: Permutation Group with generators [(1,2), (1,2,3,4)] \n             To: Matrix group over Integer Ring with 2 generators ([1], [1]).\n\n            sage: irr(4)\n            Map: \n             From: Permutation Group with generators [(1,2), (1,2,3,4)] \n             To: Matrix group over Integer Ring with 2 generators (\n            [ 0  1  0]  [ 0  0 -1]\n            [ 1  0  0]  [ 0  1  0]\n            [ 0  0 -1], [ 1  0  0]\n            ).\n\n        We define the representation by permutation on the cyclic group calculate its irreducible representations ::\n\n            sage: G = Group(CyclicPermutationGroup(6))\n            sage: irr = G.irreducible_representations(True) #Irreducible representations\n            ||||||SAIDA A SER PENSADA|||||||\n\n        We calculate the irreducible representations of the group of symmetries of a regular tetrahedron ::\n\n            sage: G = Group(AlternatingGroup(4));\n            sage: irr = G.irreducible_representations(True) #Irreducible representations\n            sage: for j in range(n):\n             ||||||SAIDA A SER PENSADA|||||||\n\n        We define the group of symmetries of regular hexagon and calculate its irreducible representations  ::\n\n            sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\n            sage: G = Group(PermutationGroup(generators))\n            sage: n,irr = G.irreducible_representations(False) #Irreducible representations\n            sage: for j in range(n):\n                    print(irr(j))\n            Map: \n             From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n             To: Matrix group over Integer Ring with 2 generators ([1], [1]).\n            Map: \n             From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n             To: Matrix group over Integer Ring with 2 generators ([1], [-1]).\n            Map: \n             From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n             To: Matrix group over Integer Ring with 2 generators ([-1], [-1]).\n            Map: \n             From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n             To: Matrix group over Integer Ring with 2 generators ([-1], [1]).\n            Map: \n             From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n             To: Matrix group over Universal Cyclotomic Field with 2 generators (\n            [E(3)^2      0]  [0 1]\n            [     0   E(3)], [1 0]\n            ).\n            Map: \n             From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n             To: Matrix group over Universal Cyclotomic Field with 2 generators (\n            [-E(3)^2       0]  [ 0 -1]\n            [      0   -E(3)], [-1  0]\n            ).\n\n        REFERENCES:\n\n        For more information, see the following references:\n\n        - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n        - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n        \"\"\"\n\n\n        irr = gap.IrreducibleRepresentations(self)\n        gens = gap.GeneratorsOfGroup(self)\n        generators = list(gap.List(gens))\n        matrices_list = []\n        for s in irr:\n            matrices = [\n                    matrix(sage_eval(str(gap.Image(s, k)))) for k in generators\n                    ]\n            matrices_list.append(matrices)\n\n        def irr_rep(n):            \n            r = representation(generators, matrices_list[n], self.field)\n            return r\n\n        N = len(matrices_list)\n        if show_table:\n\n            n = self.ngens()\n            elements = self.gens()\n\n            matrices_rep = [\n                view((irr_rep(k)(x)).matrix(), False) for k in range(N)\n                for x in elements\n                        ]\n            _table = [matrices_rep[i:i + n] for i in range(0, len(matrices_rep), n)]\n            header_row = [str(x) for x in elements]\n            header_column = [''.join(('$r^', str(k), '$')) for k in range(N)]\n            header_column.insert(0, ' ')\n\n            t = table(_table,\n                      header_row=header_row,\n                      header_column=header_column,\n                      align='center')\n            show(t)\n\n            return irr_rep\n\n        return N, irr_rep\n\n    def natural_representation(self, field=QQbar):\n    \tgens = self.gens()\n    \timage = [g.matrix() for g in gens]\n    \treturn representation(gens, image, field)\n\n    def isotypic_projection(self, right):\n        r\"\"\"\n        Return a list containing the matrices associated to projections operators over the isotypic components(or conglomerates) of right.\n\n\n        INPUT:\n\n        - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n        - ``right`` -- representation ; a representation defined over the same group as self.\n\n        OUTPUT: A list of matrices representing the projections operators over the isotypics subespaces of right.\n\n\n        EXAMPLES:\n\n        We define the symmetric group of 3 simbols and the isotypic projections associated to the regular representation of this group ::\n\n            sage: G = Group(SymmetricGroup(3));\n            sage: reg = G.regular_representation();\n            sage: G.isotypic_projection(reg)\n             [\n             [1 1 1 1 1 1]  [ 1  1  1 -1 -1 -1]  [ 2 -1 -1  0  0  0]\n             [1 1 1 1 1 1]  [ 1  1  1 -1 -1 -1]  [-1  2 -1  0  0  0]\n             [1 1 1 1 1 1]  [ 1  1  1 -1 -1 -1]  [-1 -1  2  0  0  0]\n             [1 1 1 1 1 1]  [-1 -1 -1  1  1  1]  [ 0  0  0  2 -1 -1]\n             [1 1 1 1 1 1]  [-1 -1 -1  1  1  1]  [ 0  0  0 -1  2 -1]\n             [1 1 1 1 1 1], [-1 -1 -1  1  1  1], [ 0  0  0 -1 -1  2]\n              ]\n\n        We calculate an irreducible representation of G, and the isotypic projection associated ::\n\n            sage: n,irr = G.irreducible_representations(False) #Irreducible representations\n            sage: G.isotypic_projection(irr(2))\n            [\n            [3 0]\n            [0 3]\n            ]\n\n\n        We define the representation by permutation on the cyclic group and calculate the isotypic projectors ::\n\n            sage: G = Group(CyclicPermutationGroup(4))\n            sage: generators = G.gens()\n            sage: matrices = [g.matrix() for g in generators]\n            sage: rep = representation(generators, matrices)\n            sage: G.isotypic_projection(rep)\n            [\n            [1 1 1 1]  [ 1 -1  1 -1]  [   1 -1*I   -1  1*I]  [   1  1*I   -1 -1*I]\n            [1 1 1 1]  [-1  1 -1  1]  [ 1*I    1 -1*I   -1]  [-1*I    1  1*I   -1]\n            [1 1 1 1]  [ 1 -1  1 -1]  [  -1  1*I    1 -1*I]  [  -1 -1*I    1  1*I]\n            [1 1 1 1], [-1  1 -1  1], [-1*I   -1  1*I    1], [ 1*I   -1 -1*I    1]\n            ]\n\n\n        We define a representation the group of symmetries of regular hexagon and calculate their isotypic projectors ::\n\n            sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\n            sage: rotation_pi_over_3, reflexion_about_x = matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])\n            sage: matrices = [block_diagonal_matrix(rotation_pi_over_3, rotation_pi_over_3),block_diagonal_matrix(reflexion_about_x, reflexion_about_x)];\n            sage: rep = representation(generators, matrices, field=SR)\n            sage: G = rep.domain()\n            sage: G.isotypic_projection(rep)\n            [\n            [6 0 0 0]\n            [0 6 0 0]\n            [0 0 6 0]\n            [0 0 0 6]\n            ]\n\n        TO ADD MORE EXAMPLES\n        TO ADD MORE EXAMPLES\n        TO ADD MORE EXAMPLES\n\n        REFERENCES:\n\n        For more information, see the following references:\n\n        - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n        - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n        \"\"\"\n        n, left = self.irreducible_representations(False)\n        proj_lst = []\n        for i in range(n):\n            if left(i).inner_product(right) != self.field.zero():\n                s = sum([conjugate(left(i)(g).character())*right(g).matrix()  for g in self])\n                proj_lst.append(s)\n\n        return proj_lst\n\n    def isotypic_base(self, rep, isotypic_components=False):\n        r\"\"\"\n        Return a list with the basis for each isotypic components of rep or the basis change matrix associated to the isotypic decomposition.\n\n\n        INPUT:\n\n        - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n        - ``rep`` -- representation ; a representation defined over the same group as self.\n        - ``isotypic_components`` -- a boolean (default: `False`) ; if False returns the change base matrix, if True returns a list with a base for each isotypic component :: \n\n        OUTPUT: A list with a basis for each isotypic subspace of rep or the change basis matrix to a form in blocks associated to isotypic components of rep.\n\n\n        EXAMPLES:\n\n        We define the symmetric group of 3 simbols change basis matrix associated to the isotypic decomposition  ::\n\n            sage: G = Group(SymmetricGroup(3));\n            sage: reg = G.regular_representation();\n            sage: G.isotypic_base(reg, isotypic_components=False)\n            [ 1| 1| 2 -1  0  0]\n            [ 1| 1|-1  2  0  0]\n            [ 1| 1|-1 -1  0  0]\n            [ 1|-1| 0  0  2 -1]\n            [ 1|-1| 0  0 -1  2]\n            [ 1|-1| 0  0 -1 -1]\n\n\n        The isotypic basis for each irreducible subspace associated to the regular representation of this group ::\n\n            sage: G.isotypic_base(reg, isotypic_components=True)\n            [\n            [1]  [ 1]  [ 2 -1  0  0]\n            [1]  [ 1]  [-1  2  0  0]\n            [1]  [ 1]  [-1 -1  0  0]\n            [1]  [-1]  [ 0  0  2 -1]\n            [1]  [-1]  [ 0  0 -1  2]\n            [1], [-1], [ 0  0 -1 -1]\n            ]\n\n        We define the representation by permutation on the cyclic group and calculate its isotypic decompositions ::\n\n            sage: G = Group(CyclicPermutationGroup(4))\n            sage: generators = G.gens()\n            sage: matrices = [g.matrix() for g in generators]\n            sage: rep = representation(generators, matrices)\n            sage: G.isotypic_base(rep, isotypic_components=True)\n            [\n            [1]  [ 1]  [   1]  [   1]\n            [1]  [-1]  [ 1*I]  [-1*I]\n            [1]  [ 1]  [  -1]  [  -1]\n            [1], [-1], [-1*I], [ 1*I]\n            ]\n\n            sage: change_basis = G.isotypic_base(rep, isotypic_components=False); change_basis\n            [   1|   1|   1|   1]\n            [   1|  -1| 1*I|-1*I]\n            [   1|   1|  -1|  -1]\n            [   1|  -1|-1*I| 1*I]\n            sage: [rep(g).matrix() for g in G]\n            [\n            [1 0 0 0]  [0 1 0 0]  [0 0 1 0]  [0 0 0 1]\n            [0 1 0 0]  [0 0 1 0]  [0 0 0 1]  [1 0 0 0]\n            [0 0 1 0]  [0 0 0 1]  [1 0 0 0]  [0 1 0 0]\n            [0 0 0 1], [1 0 0 0], [0 1 0 0], [0 0 1 0]\n            ]\n            sage: [change_basis.inverse()*rep(g).matrix()*change_basis for g in G]\n            [\n            [1 0 0 0]  [   1    0    0    0]  [ 1  0  0  0]  [   1    0    0    0]\n            [0 1 0 0]  [   0   -1    0    0]  [ 0  1  0  0]  [   0   -1    0    0]\n            [0 0 1 0]  [   0    0  1*I    0]  [ 0  0 -1  0]  [   0    0 -1*I    0]\n            [0 0 0 1], [   0    0    0 -1*I], [ 0  0  0 -1], [   0    0    0  1*I]\n            ]\n\n        We define a representation the group of symmetries of regular hexagon and calculate their matrix change basis(this representation is irreducible) ::\n\n            sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\n            sage: matrices = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])];\n            sage: rep = representation(generators, matrices)\n            sage: G = rep.domain()\n            sage: G.isotypic_base(rep, isotypic_components=True)\n            [\n            [6 0]\n            [0 6]\n            ]\n\n\n        TO ADD MORE EXAMPLES\n        TO ADD MORE EXAMPLES\n        TO ADD MORE EXAMPLES\n\n        REFERENCES:\n\n        For more information, see the following references:\n\n        - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n        - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n        \"\"\"\n        proj_lst = self.isotypic_projection(rep)  #NOTA:devemos usar sempre regular representation(pergunta)??? NAO\n        decomposition = [m.matrix_from_columns(m.pivots()) for m in proj_lst]\n        if isotypic_components:\n            return decomposition\n        ncols = len(decomposition)\n        return block_matrix(decomposition, ncols=ncols)\n\n    def projection(self, i, j, k, right, left=None):\n        r\"\"\"\n        Return the projection(or transfers operators) associated to irreducible subrepresentations of right.\n\n        INPUT:\n\n        - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n        - ``right`` -- representation ; a representation defined over the same group as self.\n        - ``i,j,k`` --  integers ; integers numbers representing the projection(or transfer) chosen;\n                i- will choose the irreducible representation, and its range is from 0 until the number of irreducibles. ::\n\n                j- choose a row of the matrix presentation of the irreducible, its range is the degree of chosen irreducible according i. ::\n\n                k- choose a column of the matrix presentation of the irreducible, its range is the degree of chosen irreducible according i. ::\n\n\n        OUTPUT: A matrix associated to the operator that projects over an irreducible subrepresentation of right(if j=k), or is a isomorphism between two equivalent subrepresentations of right.\n                Whenever the irreducible, chosen by index i, it is not a subrepresentation of right this matrix will be null.\n\n\n        EXAMPLES:\n\n\n        We define the representation by permutation on the cyclic group of four elements and calculate its projectors  ::\n\n            sage: G = Group(CyclicPermutationGroup(4))\n            sage: generators = G.gens()\n            sage: matrices = [g.matrix() for g in generators]\n            sage: rep = representation(generators, matrices)\n            sage: G.projection(0,0,0, rep)\n            [1 1 1 1]\n            [1 1 1 1]\n            [1 1 1 1]\n            [1 1 1 1]\n            sage: n, irr = G.irreducible_representations(False)\n            sage: list_of_projectors=[];\n            for i in range(n): # Choosing the irreducible\n                degree= irr(i).degree() # Calculation the degree of the irreducible\n                j=0;# we will use the first row\n                for k in range(degree):\n                    projector = G.projection(i,j,k, rep);\n                    list_of_projectors.append(projector)\n            sage: list_of_projectors\n            [\n            [1 1 1 1]  [ 1 -1  1 -1]  [ 1 -I -1  I]  [ 1  I -1 -I]\n            [1 1 1 1]  [-1  1 -1  1]  [ I  1 -I -1]  [-I  1  I -1]\n            [1 1 1 1]  [ 1 -1  1 -1]  [-1  I  1 -I]  [-1 -I  1  I]\n            [1 1 1 1], [-1  1 -1  1], [-I -1  I  1], [ I -1 -I  1]\n            ]\n\n\n        We define a representation on the group of symmetries of regular hexagon and calculate its projectors ::\n\n            sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\n            sage: matrices = [matrix([[1,0,0],[0,1/2,-sqrt(3)/2],[0,sqrt(3)/2,1/2]]),matrix([[1,0,0],[0,-1,0],[0,0,1]])];\n            sage: rep = representation(generators, matrices)\n            sage: G = rep.domain()\n            sage: G.projection(0,0,0, rep)\n            [     12       0       0]\n            [      0       0 0.?e-18]\n            [      0 0.?e-18       0]\n            sage: n, irr = G.irreducible_representations(False)\n            sage: list_of_projectors=[];\n            for i in range(n): # Choosing the irreducible\n                degree= irr(i).degree() # Calculation the degree of the irreducible\n                j=0;# we will use the first row\n                for k in range(degree):\n                    projector = G.projection(i,j,k, rep);\n                    list_of_projectors.append(view(projector, latex=False)) # view creates a better visualization\n            sage: list_of_projectors\n            [\n            [12  0  0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]\n            [ 0  0  0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]\n            [ 0  0  0], [0 0 0], [0 0 0], [0 0 0], [0 0 0], [0 0 0],\n\n            [   0    0    0]  [  0   0   0]\n            [   0    3  3*I]  [  0   3 3*I]\n            [   0 -3*I    3], [  0 3*I  -3]\n            ]\n\n\n        We define the regular representation over the symmetric group of 3 simbols and we calculate one of its projectors ::\n\n            sage: G = Group(SymmetricGroup(3)) \n            sage: reg = G.regular_representation();\n            sage: view(G.projection(2,1,1, reg),latex=False) # The function view creates a better visualization\n            [                   1  1/2*I*sqrt(3) - 1/2 -1/2*I*sqrt(3) - 1/2                    0                    0                    0]\n            [-1/2*I*sqrt(3) - 1/2                    1  1/2*I*sqrt(3) - 1/2                    0                    0                    0]\n            [ 1/2*I*sqrt(3) - 1/2 -1/2*I*sqrt(3) - 1/2                    1                    0                    0                    0]\n            [                   0                    0                    0                    1 -1/2*I*sqrt(3) - 1/2  1/2*I*sqrt(3) - 1/2]\n            [                   0                    0                    0  1/2*I*sqrt(3) - 1/2                    1 -1/2*I*sqrt(3) - 1/2]\n            [                   0                    0                    0 -1/2*I*sqrt(3) - 1/2  1/2*I*sqrt(3) - 1/2                    1]\n\n        REFERENCES:\n\n        For more information, see the following references:\n\n        - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n        - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n        \"\"\"\n\n\n        #Nota:   ver como melhorar a posi\u00e7\u00e3o do left\n        #Nota: right pode inclusive ser a irredutivel (pergunta)\n        ###Melhorar este nome opcoes: transfer isomorphism \n        if left == None:\n            n, left = self.irreducible_representations(False)\n        s = sum([matrix(left(i)(g.inverse()))[j][k] * matrix(right(g)) for g in self])  #Nota:\n        return s\n\n    def base_change_matrix(self, right):\n        r\"\"\"\n        Return the basis change matrix associated to a decomposition of right into irreducibles representations.\n\n\n        INPUT:\n\n        - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n        - ``right`` -- representation ; a representation defined over the same group as self.\n\n        OUTPUT: A change basis matrix that decomposes right in its irreducible components.\n\n\n        EXAMPLES:\n\n\n        We define the representation by permutation on the cyclic group of four elements and calculate its decomposition into irreducibles(Note that in this case because multiplicity we get the same result with the isotypic base)  ::\n\n            sage: G = Group(CyclicPermutationGroup(4))\n            sage: generators = G.gens()\n            sage: matrices = [g.matrix() for g in generators]\n            sage: rep = representation(generators, matrices)\n            sage: A = G.base_change_matrix(rep); A\n            [ 1  1  1  1]\n            [ 1 -1  I -I]\n            [ 1  1 -1 -1]\n            [ 1 -1 -I  I]\n\n            sage: [rep(g).matrix() for g in G]\n            [\n            [1 0 0 0]  [0 1 0 0]  [0 0 1 0]  [0 0 0 1]\n            [0 1 0 0]  [0 0 1 0]  [0 0 0 1]  [1 0 0 0]\n            [0 0 1 0]  [0 0 0 1]  [1 0 0 0]  [0 1 0 0]\n            [0 0 0 1], [1 0 0 0], [0 1 0 0], [0 0 1 0]\n            ]\n\n            sage: [A.inverse()*rep(g).matrix()*A for g in G]\n            [\n            [1 0 0 0]  [ 1  0  0  0]  [ 1  0  0  0]  [ 1  0  0  0]\n            [0 1 0 0]  [ 0 -1  0  0]  [ 0  1  0  0]  [ 0 -1  0  0]\n            [0 0 1 0]  [ 0  0  I  0]  [ 0  0 -1  0]  [ 0  0 -I  0]\n            [0 0 0 1], [ 0  0  0 -I], [ 0  0  0 -1], [ 0  0  0  I]\n            ]\n\n\n\n        We define a representation on the group of symmetries of regular hexagon and calculate its matrix change basis to decomposing into irreducible blocks ::\n\n            sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\n            sage: P = matrix([[5,3,4],[0,3,4],[0,0,4]]);P\n            sage: matrices = [P.inverse()*matrix([[1,0,0],[0,1/2,-sqrt(3)/2],[0,sqrt(3)/2,1/2]])*P,P.inverse()*matrix([[1,0,0],[0,-1,0],[0,0,1]])*P];\n            sage: rep = representation(generators, matrices, field=QQbar)\n            sage: G = rep.domain()\n            sage: B = G.base_change_matrix(rep); \n            sage: view(B,latex=False) # This function creates a better visualization of the matrix\n            [        12       -9/5      -54/5]\n            [         0    3*I + 3 -18*I + 18]\n            [         0     -9/4*I     27/2*I]\n\n            sage: [view(rep(g).matrix(), latex=False) for g in G]\n            [\n            [1 0 0]  [                 1               9/10 -2/5*sqrt(3) + 6/5]\n            [0 1 0]  [                 0  1/2*sqrt(3) - 1/2        4*sqrt(1/3)]\n            [0 0 1], [                 0       -3/8*sqrt(3) -1/2*sqrt(3) - 1/2],\n\n            [                 1               9/10  2/5*sqrt(3) + 6/5]\n            [                 0 -1/2*sqrt(3) - 1/2       -4*sqrt(1/3)]\n            [                 0        3/8*sqrt(3)  1/2*sqrt(3) - 1/2],\n\n            [                 1               3/10 -2/5*sqrt(3) + 2/5]\n            [                 0  1/2*sqrt(3) + 1/2        4*sqrt(1/3)]\n            [                 0       -3/8*sqrt(3) -1/2*sqrt(3) + 1/2],\n\n            [  1 6/5 8/5]\n            [  0  -1   0]\n            [  0   0  -1],\n\n            [                 1               3/10  2/5*sqrt(3) + 2/5]\n            [                 0 -1/2*sqrt(3) + 1/2       -4*sqrt(1/3)]\n            [                 0        3/8*sqrt(3)  1/2*sqrt(3) + 1/2],\n\n            [  1   0   0]\n            [  0   1 8/3]\n            [  0   0  -1],\n\n            [                 1               9/10 -2/5*sqrt(3) + 6/5]\n            [                 0 -1/2*sqrt(3) - 1/2               -4/3]\n            [                 0        3/8*sqrt(3)  1/2*sqrt(3) + 1/2],\n\n            [                 1               9/10  2/5*sqrt(3) + 6/5]\n            [                 0  1/2*sqrt(3) - 1/2               -4/3]\n            [                 0       -3/8*sqrt(3) -1/2*sqrt(3) + 1/2],\n\n            [                 1               3/10 -2/5*sqrt(3) + 2/5]\n            [                 0 -1/2*sqrt(3) + 1/2                4/3]\n            [                 0        3/8*sqrt(3)  1/2*sqrt(3) - 1/2],\n\n            [   1  6/5  8/5]\n            [   0   -1 -8/3]\n            [   0    0    1],\n\n            [                 1               3/10  2/5*sqrt(3) + 2/5]\n            [                 0  1/2*sqrt(3) + 1/2                4/3]\n            [                 0       -3/8*sqrt(3) -1/2*sqrt(3) - 1/2]\n            ]\n\n            sage: [view(B.inverse()*rep(g).matrix()*B, latex=False) for g in G]\n            [\n            [1 0 0]\n            [0 1 0]\n            [0 0 1],\n\n            [                   1                    0                    0]\n            [                   0 -1/2*I*sqrt(3) - 1/2                    0]\n            [                   0                    0  1/2*I*sqrt(3) - 1/2],\n\n            [                   1                    0                    0]\n            [                   0  1/2*I*sqrt(3) - 1/2                    0]\n            [                   0                    0 -1/2*I*sqrt(3) - 1/2],\n\n            [                   1                    0                    0]\n            [                   0 -1/2*I*sqrt(3) + 1/2                    0]\n            [                   0                    0  1/2*I*sqrt(3) + 1/2],\n\n            [ 1  0  0]\n            [ 0 -1  0]\n            [ 0  0 -1],\n\n            [                   1                    0                    0]\n            [                   0  1/2*I*sqrt(3) + 1/2                    0]\n            [                   0                    0 -1/2*I*sqrt(3) + 1/2],\n\n            [  1   0   0]  [                      1                       0                       0]\n            [  0   0   6]  [                      0                       0         3*I*sqrt(3) - 3]\n            [  0 1/6   0], [                      0 -1/4*I*sqrt(1/3) - 1/12                       0],\n\n            [                     1                      0                      0]  [                      1                       0                       0]\n            [                     0                      0       -3*I*sqrt(3) - 3]  [                      0                       0         3*I*sqrt(3) + 3]\n            [                     0 1/4*I*sqrt(1/3) - 1/12                      0], [                      0 -1/4*I*sqrt(1/3) + 1/12                       0],\n\n            [   1    0    0]\n            [   0    0   -6]\n            [   0 -1/6    0],\n\n            [                     1                      0                      0]\n            [                     0                      0       -3*I*sqrt(3) + 3]\n            [                     0 1/4*I*sqrt(1/3) + 1/12                      0]\n            ]\n\n\n\n\n        We define the regular representation over the symmetric group of 3 simbols and we decompose into irreducible components ::\n\n            sage: G = Group(SymmetricGroup(3)) \n            sage: reg = G.regular_representation();\n            sage: C = G.base_change_matrix(reg); \n            sage: view(C, latex=False) # This Function creates a better visualization of the matrix\n            [                   1                    1                    1                    0                    0                    3]\n            [                   1                    1  1/2*I*sqrt(3) - 1/2                    0                    0 -3/2*I*sqrt(3) - 3/2]\n            [                   1                    1 -1/2*I*sqrt(3) - 1/2                    0                    0  3/2*I*sqrt(3) - 3/2]\n            [                   1                   -1                    0                    3                    1                    0]\n            [                   1                   -1                    0  3/2*I*sqrt(3) - 3/2 -1/2*I*sqrt(3) - 1/2                    0]\n            [                   1                   -1                    0 -3/2*I*sqrt(3) - 3/2  1/2*I*sqrt(3) - 1/2                    0]\n\n            sage: g = G.an_element();\n            sage: reg(g).matrix()\n            [0 0 0 0 0 1]\n            [0 0 0 1 0 0]\n            [0 0 0 0 1 0]\n            [0 1 0 0 0 0]\n            [0 0 1 0 0 0]\n            [1 0 0 0 0 0]\n\n            sage: A = C.inverse()*reg(g).matrix()*C;\n            sage: view(A, latex=False)\n            [                    1                     0                     0                     0                     0                     0]\n            [                    0                    -1                     0                     0                     0                     0]\n            [                    0                     0                     0  -3/2*I*sqrt(3) - 3/2                     0                     0]\n            [                    0                     0 1/2*I*sqrt(1/3) - 1/6                     0                     0                     0]\n            [                    0                     0                     0                     0                     0  -3/2*I*sqrt(3) - 3/2]\n            [                    0                     0                     0                     0 1/2*I*sqrt(1/3) - 1/6                     0]\n\n\n        REFERENCES:\n\n        For more information, see the following references:\n\n        - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n        - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n        \"\"\"\n\n        #Nota: right pode inclusive ser a irredut\u00edvel????\n        row = 0\n        n, left = self.irreducible_representations(False)  #Nota: vou pensar em como implementar o __len__\n        base = []\n\n        for i in range(n):\n            multiplicity = left(i).inner_product(right) \n            if multiplicity != self.field.zero():  #Nota: acho que aqui \u00e9 um problema em caso de negativa\n                P = self.projection(i, row, 0, right, left)  #Nota: conversar com marcelo a melhor forma de deixar row opcional\n                pivots = P.pivots()\n                for pivot in pivots:\n                    v0 = P[:, pivot]\n                    degree = left(i).degree()\n                    base.append(v0)\n\n                    for k in range(1, degree):\n                        v = self.projection(i, row, k, right, left) * v0\n\n                        base.append(v)       \n        b = base[0]\n        for v in base[1:]:\n            b = b.augment(v)  #Nota: verificar de \u00e9 mais edequado. A\u00ed n\u00e3o precisa do numero de colunas\n        #     #base_change_matrix = block_matrix(base, ncols=ncols)\n        return b #IsotypicBase(base)\n\n\n    def base_change_matrix_new_off_filter_optimization(self, right, row=0):\n        r\"\"\"\n        Return the basis change matrix associated to a symmetry adapted basis to an equivariant operator of right.\n\n\n        INPUT:\n\n        - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n        - ``right`` -- representation ; a representation defined over the same group as self.\n        - ``row`` -- an integer (default: 0) ; an integer in the range of the degree of right, this number will choose the set o projectors to be chosen in the contruction of the base :: \n\n        OUTPUT: A change basis matrix that decomposes the equivariant operator.\n\n\n        EXAMPLES:\n\n\n        We define the representation by permutation on the cyclic group of four elements and decompose an equivariant operator under this representation  ::\n\n            sage: G = Group(CyclicPermutationGroup(4))\n            sage: generators = G.gens()\n            sage: matrices = [g.matrix() for g in generators]\n            sage: rep = representation(generators, matrices)\n            sage: A = matrix.circulant([1,2,3,4])\n            sage: rep.is_equivariant_to(A)\n            True\n            sage: P = G.base_change_matrix_new_off_filter_optimization(rep); P\n            [ 1  1  1  1]\n            [ 1 -1  I -I]\n            [ 1  1 -1 -1]\n            [ 1 -1 -I  I]\n            sage: A, P.inverse()*A*P\n            (\n            [1 2 3 4]  [      10        0        0        0]\n            [4 1 2 3]  [       0       -2        0        0]\n            [3 4 1 2]  [       0        0 -2*I - 2        0]\n            [2 3 4 1], [       0        0        0  2*I - 2]\n            )\n\n\n\n        We define a representation on the permutation group, and decompose an equivariant operator  ::\n\n            sage: G = Group(['(2,4)(3,7)(6,8)', '(1,3)(4,6)(7,9)'])\n            sage: gens = G.gens()\n            sage: matrices = [g.matrix() for g in gens]\n            sage: rep = representation(gens, matrices)\n            sage: operator = matrix([[ 4, -1, -0, -1, -0, -0, -0, -0, -0],\n                                    [-1,  4, -1, -0, -1, -0, -0, -0, -0],\n                                    [-0, -1,  4, -0, -0, -1, -0, -0, -0],\n                                    [-1, -0, -0,  4, -1, -0, -1, -0, -0],\n                                    [-0, -1, -0, -1,  4, -1, -0, -1, -0],\n                                    [-0, -0, -1, -0, -1,  4, -0, -0, -1],\n                                    [-0, -0, -0, -1, -0, -0,  4, -1, -0],\n                                    [-0, -0, -0, -0, -1, -0, -1,  4, -1],\n                                    [-0, -0, -0, -0, -0, -1, -0, -1,  4]])\n            sage: rep.is_equivariant_to(operator)\n            True\n            sage: P = G.base_change_matrix_new_off_filter_optimization(rep); P\n            [ 2  0  0  2  0  2  0  0  0]\n            [ 0  2  0  0  2  0  1  0  4]\n            [ 2  0  0 -2  0  0  0  8  0]\n            [ 0  2  0  0 -2  0  1  0 -4]\n            [ 0  0  8  0  0  0  0  0  0]\n            [ 0  2  0  0 -2  0 -1  0  4]\n            [ 2  0  0 -2  0  0  0 -8  0]\n            [ 0  2  0  0  2  0 -1  0 -4]\n            [ 2  0  0  2  0 -2  0  0  0]\n            sage: operator, P.inverse()*operator*P\n            (\n            [ 4 -1  0 -1  0  0  0  0  0]  [ 4 -2  0  0  0  0  0  0  0]\n            [-1  4 -1  0 -1  0  0  0  0]  [-2  4 -4  0  0  0  0  0  0]\n            [ 0 -1  4  0  0 -1  0  0  0]  [ 0 -1  4  0  0  0  0  0  0]\n            [-1  0  0  4 -1  0 -1  0  0]  [ 0  0  0  4  0  0  0  0  0]\n            [ 0 -1  0 -1  4 -1  0 -1  0]  [ 0  0  0  0  4  0  0  0  0]\n            [ 0  0 -1  0 -1  4  0  0 -1]  [ 0  0  0  0  0  4 -1  0  0]\n            [ 0  0  0 -1  0  0  4 -1  0]  [ 0  0  0  0  0 -2  4  0  0]\n            [ 0  0  0  0 -1  0 -1  4 -1]  [ 0  0  0  0  0  0  0  4 -1]\n            [ 0  0  0  0  0 -1  0 -1  4], [ 0  0  0  0  0  0  0 -2  4]\n            )\n\n        TO ADD MORE EXAMPLES\n        TO ADD MORE EXAMPLES\n        TO ADD MORE EXAMPLES\n\n\n        REFERENCES:\n\n        For more information, see the following references:\n\n        - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n        - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n        \"\"\"\n        ###Mudar Nome, talvez symmetry_adapted_basis\n        #Nota: right pode inclusive ser a irredut\u00edvel???? PODE\n        n, left = self.irreducible_representations(False)  #Nota: vou pensar em como implementar o __len__\n        base = []\n\n        for i in range(n):\n\n            if left(i).inner_product(right) != self.field.zero():  #Nota: acho que aqui \u00e9 um problema em caso de negativa\n                P = self.projection(i, row, 0, right, left)  #Nota: conversar com marcelo a melhor forma de deixar row opcional. #nota: left???\n                pivots = P.pivots()\n                geracao1 = []\n                for pivot in pivots:\n                    v0 = P[:, pivot]\n                    geracao1.append(v0)\n                base = base + geracao1 # Nota: Traduzir\n                degree = left(i).degree()\n\n                for k in range(1, degree):  #Nota: Esse laco roda se o range for vazio? Otimizar\n                    geracao2 = []\n                    for v0 in geracao1:     # Nota: Traduzir\n                        v = self.projection(i, row, k, right, left) * v0\n                        geracao2.append(v)    # Nota: Traduzir\n                    base = base + geracao2\n\n        b = base[0]\n        for v in base[1:]:\n            b = b.augment(v)  #Nota: verificar se \u00e9 mais edequado. A\u00ed n\u00e3o precisa do numero de colunas\n            #base_change_matrix = block_matrix(base, ncols=ncols)\n        return b #IsotypicBase(base)\n\n    #####################################################################################\n    def quick_block_prevision(self, right, block_prevision=False):##Nota, consertar row ##Revisar a documentacao do True or False\n        r\"\"\"\n        Return a list with order and multiplicities of blocks to an equivariant operator under right defined on self.\n\n        INPUT:\n\n        - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n        - ``right`` -- representation ; a representation defined over an arbitrary group given by self.\n        - ``block_prevision`` -- a boolean (default: `False`) ; if set to True then prints a string describing the number and orders of blocks to an equivariant operator under right.\n\n        OUTPUT: A list indicating the degree and multiplicity of the representation defined by right. \n\n\n        EXAMPLES:\n\n        We define the regular representation(reg) over the symmetric group of 4 simbols and calculate the structure of an equivariant operator under reg ::\n\n            sage: H = SymmetricGroup(4)\n            sage: G = Group(H);\n            sage: reg = G.regular_representation();\n            sage: G.quick_block_prevision(reg)\n            [['degree', 'multiplicity'], [1, 1], [1, 1], [2, 2], [3, 3], [3, 3]]\n\n            sage: G.quick_block_prevision(reg, block_prevision=True)\n            1 block size 1x1\n            1 block size 1x1\n            2 block size 2x2\n            3 block size 3x3\n            3 block size 3x3\n            [['degree', 'multiplicity'], [1, 1], [1, 1], [2, 2], [3, 3], [3, 3]]\n\n        We define the representation by permutation on the cyclic group and calculate the structure of an equivariant operator ::\n\n            sage: G = Group(CyclicPermutationGroup(4))\n            sage: generators = G.gens()\n            sage: matrices = [g.matrix() for g in generators]\n            sage: rep = representation(generators, matrices)\n            sage: G.quick_block_prevision(rep, block_prevision=True)\n            1 block size 1x1\n            1 block size 1x1\n            1 block size 1x1\n            1 block size 1x1\n            [['degree', 'multiplicity'], [1, 1], [1, 1], [1, 1], [1, 1]]\n\n        We calculate the irreducible representations of the group of symmetries of tetrahedron and calculate the structure of an equivariant operator inder its irreducibles ::\n\n            sage: G = Group(AlternatingGroup(4));\n            sage: n,irr = G.irreducible_representations(False) ##Irreducible representations\n            sage: for j in range(n):\n                    print(G.quick_block_prevision(irr(j),block_prevision=True))\n            1 block size 1x1\n            [['degree', 'multiplicity'], [1, 1]]\n            1 block size 1x1\n            [['degree', 'multiplicity'], [1, 1]]\n            1 block size 1x1\n            [['degree', 'multiplicity'], [1, 1]]\n            3 block size 1x1\n            [['degree', 'multiplicity'], [3, 1]]\n\n\n\n        We define two representation rep and rep1 on the group of symmetries of regular hexagon and calculate the structure of an equivariant operator under each one ::\n\n            sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\n            sage: matrices = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])];\n            sage: rep = representation(generators, matrices)\n            sage: G = rep.domain()\n            sage: G.quick_block_prevision(rep,block_prevision=True)\n            2 block size 1x1\n            [['degree', 'multiplicity'], [2, 1]]\n\n            sage: P = matrix([[2,1],[15,2]]); #A change of basis\n            sage: matrices1 = [ block_diagonal_matrix((P.inverse())*A*P, (P.inverse())*A*P) for A in matrices];\n            sage: rep1 = representation(generators, matrices1)\n            sage: G.quick_block_prevision(rep1,block_prevision=True)\n            2 block size 2x2\n            [['degree', 'multiplicity'], [2, 2]]\n\n\n        REFERENCES:\n\n        For more information, see the following references:\n\n        - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n        - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n        \"\"\"        \n        n, left = self.irreducible_representations(False) \n\n        info = [['degree', 'multiplicity']]        \n        for i in range(n):\n        \tmultiplicity = left(i).inner_product(right)\n        \ttry:\n        \t\tmultiplicity = multiplicity.radical_expression()\n        \texcept: AttributeError\n        \tif multiplicity != self.field.zero():\n        \t\tdegree = left(i).degree()\n        \t\tinfo.append([degree, multiplicity])\n        if block_prevision:\n        \tfor k in info[1:]:\n        \t\tprint(str(k[0]) + ' block size ' + str(k[1]) + 'x' + str(k[1]) )\n        return info\n\n\n    #Nota: Falta unificar as saidas das bases    \n    def base_change_eigenvalue_reduction_new(self, right, block_prevision=False):\n        r\"\"\"\n        Return part of basis change matrix associated to a symmetry adapted basis to an equivariant operator of right.\n\n\n        INPUT:\n\n        - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n        - ``right`` -- representation ; a representation defined over the same group as self.        \n        - ``block_prevision`` -- a boolean (default: `False`) ; if set to True then prints a string describing the number and orders of blocks to an equivariant operator under right.\n\n        OUTPUT: A list of basis subespaces, along with degree and multiplicitie(number of equivalent copies).\n        The restriction of an equivariant operator to each subespace gives a different block matrix of the equivariant operator relative to the symmetry adapted basis.\n        In short, these are parts of the symmetry adapted basis that no generates block repetitions.\n\n        EXAMPLES:\n\n\n        We define the representation by permutation on the cyclic group of four elements and calculates the subspaces that gives one copy of each block of the equivariant operator under this representation  ::\n\n            sage: G = Group(CyclicPermutationGroup(4))\n            sage: generators = G.gens()\n            sage: matrices = [g.matrix() for g in generators]\n            sage: rep = representation(generators, matrices)\n            sage: G.base_change_eigenvalue_reduction_new(rep)\n            ([[\n            [1]        \n            [1]        \n            [1]        \n            [1], [1, 1]\n            ],\n              [\n            [ 1]        \n            [-1]        \n            [ 1]        \n            [-1], [1, 1]\n            ],\n              [\n            [ 1]        \n            [ I]        \n            [-1]        \n            [-I], [1, 1]\n            ],\n              [\n            [ 1]        \n            [-I]        \n            [-1]        \n            [ I], [1, 1]\n            ]],\n             [['degree', 'multiplicity'], [1, 1], [1, 1], [1, 1], [1, 1]])\n\n            sage: G.base_change_eigenvalue_reduction_new(rep, block_prevision=True)\n            1 block size 1x1\n            1 block size 1x1\n            1 block size 1x1\n            1 block size 1x1\n            ([[\n            [1]        \n            [1]        \n            [1]        \n            [1], [1, 1]\n            ],\n              [\n            [ 1]        \n            [-1]        \n            [ 1]        \n            [-1], [1, 1]\n            ],\n              [\n            [ 1]        \n            [ I]        \n            [-1]        \n            [-I], [1, 1]\n            ],\n              [\n            [ 1]        \n            [-I]        \n            [-1]        \n            [ I], [1, 1]\n            ]],\n             [['degree', 'multiplicity'], [1, 1], [1, 1], [1, 1], [1, 1]])\n\n\n\n        We define a representation on the permutation group, and calculates parts of the symmetry adapted basis that generates no repetition in the blocks of an equivariant operator  ::\n\n            sage: G = Group(['(2,4)(3,7)(6,8)', '(1,3)(4,6)(7,9)'])\n            sage: gens = G.gens()\n            sage: matrices = [g.matrix() for g in gens]\n            sage: rep = representation(gens, matrices)\n            sage: G.base_change_eigenvalue_reduction_new(rep)\n            ([[\n            [2 0 0]        \n            [0 2 0]        \n            [2 0 0]        \n            [0 2 0]        \n            [0 0 8]        \n            [0 2 0]        \n            [2 0 0]        \n            [0 2 0]        \n            [2 0 0], [1, 3]\n            ],\n              [\n            [ 2]        \n            [ 0]        \n            [-2]        \n            [ 0]        \n            [ 0]        \n            [ 0]        \n            [-2]        \n            [ 0]        \n            [ 2], [1, 1]\n            ],\n              [\n            [ 0]        \n            [ 2]        \n            [ 0]        \n            [-2]        \n            [ 0]        \n            [-2]        \n            [ 0]        \n            [ 2]        \n            [ 0], [1, 1]\n            ],\n              [\n            [ 2  0]        \n            [ 0  1]        \n            [ 0  0]        \n            [ 0  1]        \n            [ 0  0]        \n            [ 0 -1]        \n            [ 0  0]        \n            [ 0 -1]        \n            [-2  0], [2, 2]\n            ]],\n             [['degree', 'multiplicity'], [1, 3], [1, 1], [1, 1], [2, 2]])\n\n        We define the regular representation(reg) over the symmetric group of 3 simbols and calculate the subspaces that gives all the blocks of an equivariant operator without repetition ::\n\n            sage: H = SymmetricGroup(3)\n            sage: G = Group(H);\n            sage: reg = G.regular_representation();\n            sage: G.base_change_eigenvalue_reduction_new(reg,block_prevision=True)\n            1 block size 1x1\n            1 block size 1x1\n            2 block size 2x2\n            ([[\n            [1]        \n            [1]        \n            [1]        \n            [1]        \n            [1]        \n            [1], [1, 1]\n            ],\n              [\n            [ 1]        \n            [ 1]        \n            [ 1]        \n            [-1]        \n            [-1]        \n            [-1], [1, 1]\n            ],\n              [\n            [                                         1                                          0]\n            [-0.500000000000000? + 0.866025403784439?*I                                          0]\n            [-0.500000000000000? - 0.866025403784439?*I                                          0]\n            [                                         0                                          1]\n            [                                         0 -0.500000000000000? - 0.866025403784439?*I]\n            [                                         0 -0.500000000000000? + 0.866025403784439?*I],\n\n            [2, 2]\n            ]],\n             [['degree', 'multiplicity'], [1, 1], [1, 1], [2, 2]])\n\n\n\n        REFERENCES:\n\n        For more information, see the following references:\n\n        - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n        - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n        \"\"\"       \n        row = 0\n        n, left = self.irreducible_representations(False)  #Nota: vou pensar em como implementar o __len__\n        base = []\n        #base_new = []\n        info = [['degree', 'multiplicity']]\n\n        for i in range(n):\n            multiplicity = left(i).inner_product(right)\n            if multiplicity != self.field.zero():  \n\n                P = self.projection(i, row, 0, right, left)  #Nota: left???\n                pivots = P.pivots()\n                degree = left(i).degree()                \n                v0 = P[:, pivots]\n                base.append([v0, [degree, multiplicity]])\n                info.append([degree, multiplicity])\n        if block_prevision:\n            for k in info[1:]:\n                print(str(k[0]) + ' block size ' + str(k[1]) + 'x' + str(k[1]) )\n        return base, info\n</code></pre>"},{"location":"api/#pysymmetry.Group.base_change_eigenvalue_reduction_new","title":"<code>base_change_eigenvalue_reduction_new(right, block_prevision=False)</code>","text":"<p>Return part of basis change matrix associated to a symmetry adapted basis to an equivariant operator of right.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- Group ; a  Sage permutation group or a group of the class Group.</li> <li><code>right</code> -- representation ; a representation defined over the same group as self.        </li> <li><code>block_prevision</code> -- a boolean (default: <code>False</code>) ; if set to True then prints a string describing the number and orders of blocks to an equivariant operator under right.</li> </ul> <p>OUTPUT: A list of basis subespaces, along with degree and multiplicitie(number of equivalent copies). The restriction of an equivariant operator to each subespace gives a different block matrix of the equivariant operator relative to the symmetry adapted basis. In short, these are parts of the symmetry adapted basis that no generates block repetitions.</p> <p>EXAMPLES:</p> <p>We define the representation by permutation on the cyclic group of four elements and calculates the subspaces that gives one copy of each block of the equivariant operator under this representation  ::</p> <pre><code>sage: G = Group(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: G.base_change_eigenvalue_reduction_new(rep)\n([[\n[1]        \n[1]        \n[1]        \n[1], [1, 1]\n],\n  [\n[ 1]        \n[-1]        \n[ 1]        \n[-1], [1, 1]\n],\n  [\n[ 1]        \n[ I]        \n[-1]        \n[-I], [1, 1]\n],\n  [\n[ 1]        \n[-I]        \n[-1]        \n[ I], [1, 1]\n]],\n [['degree', 'multiplicity'], [1, 1], [1, 1], [1, 1], [1, 1]])\n\nsage: G.base_change_eigenvalue_reduction_new(rep, block_prevision=True)\n1 block size 1x1\n1 block size 1x1\n1 block size 1x1\n1 block size 1x1\n([[\n[1]        \n[1]        \n[1]        \n[1], [1, 1]\n],\n  [\n[ 1]        \n[-1]        \n[ 1]        \n[-1], [1, 1]\n],\n  [\n[ 1]        \n[ I]        \n[-1]        \n[-I], [1, 1]\n],\n  [\n[ 1]        \n[-I]        \n[-1]        \n[ I], [1, 1]\n]],\n [['degree', 'multiplicity'], [1, 1], [1, 1], [1, 1], [1, 1]])\n</code></pre> <p>We define a representation on the permutation group, and calculates parts of the symmetry adapted basis that generates no repetition in the blocks of an equivariant operator  ::</p> <pre><code>sage: G = Group(['(2,4)(3,7)(6,8)', '(1,3)(4,6)(7,9)'])\nsage: gens = G.gens()\nsage: matrices = [g.matrix() for g in gens]\nsage: rep = representation(gens, matrices)\nsage: G.base_change_eigenvalue_reduction_new(rep)\n([[\n[2 0 0]        \n[0 2 0]        \n[2 0 0]        \n[0 2 0]        \n[0 0 8]        \n[0 2 0]        \n[2 0 0]        \n[0 2 0]        \n[2 0 0], [1, 3]\n],\n  [\n[ 2]        \n[ 0]        \n[-2]        \n[ 0]        \n[ 0]        \n[ 0]        \n[-2]        \n[ 0]        \n[ 2], [1, 1]\n],\n  [\n[ 0]        \n[ 2]        \n[ 0]        \n[-2]        \n[ 0]        \n[-2]        \n[ 0]        \n[ 2]        \n[ 0], [1, 1]\n],\n  [\n[ 2  0]        \n[ 0  1]        \n[ 0  0]        \n[ 0  1]        \n[ 0  0]        \n[ 0 -1]        \n[ 0  0]        \n[ 0 -1]        \n[-2  0], [2, 2]\n]],\n [['degree', 'multiplicity'], [1, 3], [1, 1], [1, 1], [2, 2]])\n</code></pre> <p>We define the regular representation(reg) over the symmetric group of 3 simbols and calculate the subspaces that gives all the blocks of an equivariant operator without repetition ::</p> <pre><code>sage: H = SymmetricGroup(3)\nsage: G = Group(H);\nsage: reg = G.regular_representation();\nsage: G.base_change_eigenvalue_reduction_new(reg,block_prevision=True)\n1 block size 1x1\n1 block size 1x1\n2 block size 2x2\n([[\n[1]        \n[1]        \n[1]        \n[1]        \n[1]        \n[1], [1, 1]\n],\n  [\n[ 1]        \n[ 1]        \n[ 1]        \n[-1]        \n[-1]        \n[-1], [1, 1]\n],\n  [\n[                                         1                                          0]\n[-0.500000000000000? + 0.866025403784439?*I                                          0]\n[-0.500000000000000? - 0.866025403784439?*I                                          0]\n[                                         0                                          1]\n[                                         0 -0.500000000000000? - 0.866025403784439?*I]\n[                                         0 -0.500000000000000? + 0.866025403784439?*I],\n\n[2, 2]\n]],\n [['degree', 'multiplicity'], [1, 1], [1, 1], [2, 2]])\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul> Source code in <code>pysymmetry/pysymmetry.py</code> <pre><code>def base_change_eigenvalue_reduction_new(self, right, block_prevision=False):\n    r\"\"\"\n    Return part of basis change matrix associated to a symmetry adapted basis to an equivariant operator of right.\n\n\n    INPUT:\n\n    - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n    - ``right`` -- representation ; a representation defined over the same group as self.        \n    - ``block_prevision`` -- a boolean (default: `False`) ; if set to True then prints a string describing the number and orders of blocks to an equivariant operator under right.\n\n    OUTPUT: A list of basis subespaces, along with degree and multiplicitie(number of equivalent copies).\n    The restriction of an equivariant operator to each subespace gives a different block matrix of the equivariant operator relative to the symmetry adapted basis.\n    In short, these are parts of the symmetry adapted basis that no generates block repetitions.\n\n    EXAMPLES:\n\n\n    We define the representation by permutation on the cyclic group of four elements and calculates the subspaces that gives one copy of each block of the equivariant operator under this representation  ::\n\n        sage: G = Group(CyclicPermutationGroup(4))\n        sage: generators = G.gens()\n        sage: matrices = [g.matrix() for g in generators]\n        sage: rep = representation(generators, matrices)\n        sage: G.base_change_eigenvalue_reduction_new(rep)\n        ([[\n        [1]        \n        [1]        \n        [1]        \n        [1], [1, 1]\n        ],\n          [\n        [ 1]        \n        [-1]        \n        [ 1]        \n        [-1], [1, 1]\n        ],\n          [\n        [ 1]        \n        [ I]        \n        [-1]        \n        [-I], [1, 1]\n        ],\n          [\n        [ 1]        \n        [-I]        \n        [-1]        \n        [ I], [1, 1]\n        ]],\n         [['degree', 'multiplicity'], [1, 1], [1, 1], [1, 1], [1, 1]])\n\n        sage: G.base_change_eigenvalue_reduction_new(rep, block_prevision=True)\n        1 block size 1x1\n        1 block size 1x1\n        1 block size 1x1\n        1 block size 1x1\n        ([[\n        [1]        \n        [1]        \n        [1]        \n        [1], [1, 1]\n        ],\n          [\n        [ 1]        \n        [-1]        \n        [ 1]        \n        [-1], [1, 1]\n        ],\n          [\n        [ 1]        \n        [ I]        \n        [-1]        \n        [-I], [1, 1]\n        ],\n          [\n        [ 1]        \n        [-I]        \n        [-1]        \n        [ I], [1, 1]\n        ]],\n         [['degree', 'multiplicity'], [1, 1], [1, 1], [1, 1], [1, 1]])\n\n\n\n    We define a representation on the permutation group, and calculates parts of the symmetry adapted basis that generates no repetition in the blocks of an equivariant operator  ::\n\n        sage: G = Group(['(2,4)(3,7)(6,8)', '(1,3)(4,6)(7,9)'])\n        sage: gens = G.gens()\n        sage: matrices = [g.matrix() for g in gens]\n        sage: rep = representation(gens, matrices)\n        sage: G.base_change_eigenvalue_reduction_new(rep)\n        ([[\n        [2 0 0]        \n        [0 2 0]        \n        [2 0 0]        \n        [0 2 0]        \n        [0 0 8]        \n        [0 2 0]        \n        [2 0 0]        \n        [0 2 0]        \n        [2 0 0], [1, 3]\n        ],\n          [\n        [ 2]        \n        [ 0]        \n        [-2]        \n        [ 0]        \n        [ 0]        \n        [ 0]        \n        [-2]        \n        [ 0]        \n        [ 2], [1, 1]\n        ],\n          [\n        [ 0]        \n        [ 2]        \n        [ 0]        \n        [-2]        \n        [ 0]        \n        [-2]        \n        [ 0]        \n        [ 2]        \n        [ 0], [1, 1]\n        ],\n          [\n        [ 2  0]        \n        [ 0  1]        \n        [ 0  0]        \n        [ 0  1]        \n        [ 0  0]        \n        [ 0 -1]        \n        [ 0  0]        \n        [ 0 -1]        \n        [-2  0], [2, 2]\n        ]],\n         [['degree', 'multiplicity'], [1, 3], [1, 1], [1, 1], [2, 2]])\n\n    We define the regular representation(reg) over the symmetric group of 3 simbols and calculate the subspaces that gives all the blocks of an equivariant operator without repetition ::\n\n        sage: H = SymmetricGroup(3)\n        sage: G = Group(H);\n        sage: reg = G.regular_representation();\n        sage: G.base_change_eigenvalue_reduction_new(reg,block_prevision=True)\n        1 block size 1x1\n        1 block size 1x1\n        2 block size 2x2\n        ([[\n        [1]        \n        [1]        \n        [1]        \n        [1]        \n        [1]        \n        [1], [1, 1]\n        ],\n          [\n        [ 1]        \n        [ 1]        \n        [ 1]        \n        [-1]        \n        [-1]        \n        [-1], [1, 1]\n        ],\n          [\n        [                                         1                                          0]\n        [-0.500000000000000? + 0.866025403784439?*I                                          0]\n        [-0.500000000000000? - 0.866025403784439?*I                                          0]\n        [                                         0                                          1]\n        [                                         0 -0.500000000000000? - 0.866025403784439?*I]\n        [                                         0 -0.500000000000000? + 0.866025403784439?*I],\n\n        [2, 2]\n        ]],\n         [['degree', 'multiplicity'], [1, 1], [1, 1], [2, 2]])\n\n\n\n    REFERENCES:\n\n    For more information, see the following references:\n\n    - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n    - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n    \"\"\"       \n    row = 0\n    n, left = self.irreducible_representations(False)  #Nota: vou pensar em como implementar o __len__\n    base = []\n    #base_new = []\n    info = [['degree', 'multiplicity']]\n\n    for i in range(n):\n        multiplicity = left(i).inner_product(right)\n        if multiplicity != self.field.zero():  \n\n            P = self.projection(i, row, 0, right, left)  #Nota: left???\n            pivots = P.pivots()\n            degree = left(i).degree()                \n            v0 = P[:, pivots]\n            base.append([v0, [degree, multiplicity]])\n            info.append([degree, multiplicity])\n    if block_prevision:\n        for k in info[1:]:\n            print(str(k[0]) + ' block size ' + str(k[1]) + 'x' + str(k[1]) )\n    return base, info\n</code></pre>"},{"location":"api/#pysymmetry.Group.base_change_matrix","title":"<code>base_change_matrix(right)</code>","text":"<p>Return the basis change matrix associated to a decomposition of right into irreducibles representations.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- Group ; a  Sage permutation group or a group of the class Group.</li> <li><code>right</code> -- representation ; a representation defined over the same group as self.</li> </ul> <p>OUTPUT: A change basis matrix that decomposes right in its irreducible components.</p> <p>EXAMPLES:</p> <p>We define the representation by permutation on the cyclic group of four elements and calculate its decomposition into irreducibles(Note that in this case because multiplicity we get the same result with the isotypic base)  ::</p> <pre><code>sage: G = Group(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: A = G.base_change_matrix(rep); A\n[ 1  1  1  1]\n[ 1 -1  I -I]\n[ 1  1 -1 -1]\n[ 1 -1 -I  I]\n\nsage: [rep(g).matrix() for g in G]\n[\n[1 0 0 0]  [0 1 0 0]  [0 0 1 0]  [0 0 0 1]\n[0 1 0 0]  [0 0 1 0]  [0 0 0 1]  [1 0 0 0]\n[0 0 1 0]  [0 0 0 1]  [1 0 0 0]  [0 1 0 0]\n[0 0 0 1], [1 0 0 0], [0 1 0 0], [0 0 1 0]\n]\n\nsage: [A.inverse()*rep(g).matrix()*A for g in G]\n[\n[1 0 0 0]  [ 1  0  0  0]  [ 1  0  0  0]  [ 1  0  0  0]\n[0 1 0 0]  [ 0 -1  0  0]  [ 0  1  0  0]  [ 0 -1  0  0]\n[0 0 1 0]  [ 0  0  I  0]  [ 0  0 -1  0]  [ 0  0 -I  0]\n[0 0 0 1], [ 0  0  0 -I], [ 0  0  0 -1], [ 0  0  0  I]\n]\n</code></pre> <p>We define a representation on the group of symmetries of regular hexagon and calculate its matrix change basis to decomposing into irreducible blocks ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: P = matrix([[5,3,4],[0,3,4],[0,0,4]]);P\nsage: matrices = [P.inverse()*matrix([[1,0,0],[0,1/2,-sqrt(3)/2],[0,sqrt(3)/2,1/2]])*P,P.inverse()*matrix([[1,0,0],[0,-1,0],[0,0,1]])*P];\nsage: rep = representation(generators, matrices, field=QQbar)\nsage: G = rep.domain()\nsage: B = G.base_change_matrix(rep); \nsage: view(B,latex=False) # This function creates a better visualization of the matrix\n[        12       -9/5      -54/5]\n[         0    3*I + 3 -18*I + 18]\n[         0     -9/4*I     27/2*I]\n\nsage: [view(rep(g).matrix(), latex=False) for g in G]\n[\n[1 0 0]  [                 1               9/10 -2/5*sqrt(3) + 6/5]\n[0 1 0]  [                 0  1/2*sqrt(3) - 1/2        4*sqrt(1/3)]\n[0 0 1], [                 0       -3/8*sqrt(3) -1/2*sqrt(3) - 1/2],\n\n[                 1               9/10  2/5*sqrt(3) + 6/5]\n[                 0 -1/2*sqrt(3) - 1/2       -4*sqrt(1/3)]\n[                 0        3/8*sqrt(3)  1/2*sqrt(3) - 1/2],\n\n[                 1               3/10 -2/5*sqrt(3) + 2/5]\n[                 0  1/2*sqrt(3) + 1/2        4*sqrt(1/3)]\n[                 0       -3/8*sqrt(3) -1/2*sqrt(3) + 1/2],\n\n[  1 6/5 8/5]\n[  0  -1   0]\n[  0   0  -1],\n\n[                 1               3/10  2/5*sqrt(3) + 2/5]\n[                 0 -1/2*sqrt(3) + 1/2       -4*sqrt(1/3)]\n[                 0        3/8*sqrt(3)  1/2*sqrt(3) + 1/2],\n\n[  1   0   0]\n[  0   1 8/3]\n[  0   0  -1],\n\n[                 1               9/10 -2/5*sqrt(3) + 6/5]\n[                 0 -1/2*sqrt(3) - 1/2               -4/3]\n[                 0        3/8*sqrt(3)  1/2*sqrt(3) + 1/2],\n\n[                 1               9/10  2/5*sqrt(3) + 6/5]\n[                 0  1/2*sqrt(3) - 1/2               -4/3]\n[                 0       -3/8*sqrt(3) -1/2*sqrt(3) + 1/2],\n\n[                 1               3/10 -2/5*sqrt(3) + 2/5]\n[                 0 -1/2*sqrt(3) + 1/2                4/3]\n[                 0        3/8*sqrt(3)  1/2*sqrt(3) - 1/2],\n\n[   1  6/5  8/5]\n[   0   -1 -8/3]\n[   0    0    1],\n\n[                 1               3/10  2/5*sqrt(3) + 2/5]\n[                 0  1/2*sqrt(3) + 1/2                4/3]\n[                 0       -3/8*sqrt(3) -1/2*sqrt(3) - 1/2]\n]\n\nsage: [view(B.inverse()*rep(g).matrix()*B, latex=False) for g in G]\n[\n[1 0 0]\n[0 1 0]\n[0 0 1],\n\n[                   1                    0                    0]\n[                   0 -1/2*I*sqrt(3) - 1/2                    0]\n[                   0                    0  1/2*I*sqrt(3) - 1/2],\n\n[                   1                    0                    0]\n[                   0  1/2*I*sqrt(3) - 1/2                    0]\n[                   0                    0 -1/2*I*sqrt(3) - 1/2],\n\n[                   1                    0                    0]\n[                   0 -1/2*I*sqrt(3) + 1/2                    0]\n[                   0                    0  1/2*I*sqrt(3) + 1/2],\n\n[ 1  0  0]\n[ 0 -1  0]\n[ 0  0 -1],\n\n[                   1                    0                    0]\n[                   0  1/2*I*sqrt(3) + 1/2                    0]\n[                   0                    0 -1/2*I*sqrt(3) + 1/2],\n\n[  1   0   0]  [                      1                       0                       0]\n[  0   0   6]  [                      0                       0         3*I*sqrt(3) - 3]\n[  0 1/6   0], [                      0 -1/4*I*sqrt(1/3) - 1/12                       0],\n\n[                     1                      0                      0]  [                      1                       0                       0]\n[                     0                      0       -3*I*sqrt(3) - 3]  [                      0                       0         3*I*sqrt(3) + 3]\n[                     0 1/4*I*sqrt(1/3) - 1/12                      0], [                      0 -1/4*I*sqrt(1/3) + 1/12                       0],\n\n[   1    0    0]\n[   0    0   -6]\n[   0 -1/6    0],\n\n[                     1                      0                      0]\n[                     0                      0       -3*I*sqrt(3) + 3]\n[                     0 1/4*I*sqrt(1/3) + 1/12                      0]\n]\n</code></pre> <p>We define the regular representation over the symmetric group of 3 simbols and we decompose into irreducible components ::</p> <pre><code>sage: G = Group(SymmetricGroup(3)) \nsage: reg = G.regular_representation();\nsage: C = G.base_change_matrix(reg); \nsage: view(C, latex=False) # This Function creates a better visualization of the matrix\n[                   1                    1                    1                    0                    0                    3]\n[                   1                    1  1/2*I*sqrt(3) - 1/2                    0                    0 -3/2*I*sqrt(3) - 3/2]\n[                   1                    1 -1/2*I*sqrt(3) - 1/2                    0                    0  3/2*I*sqrt(3) - 3/2]\n[                   1                   -1                    0                    3                    1                    0]\n[                   1                   -1                    0  3/2*I*sqrt(3) - 3/2 -1/2*I*sqrt(3) - 1/2                    0]\n[                   1                   -1                    0 -3/2*I*sqrt(3) - 3/2  1/2*I*sqrt(3) - 1/2                    0]\n\nsage: g = G.an_element();\nsage: reg(g).matrix()\n[0 0 0 0 0 1]\n[0 0 0 1 0 0]\n[0 0 0 0 1 0]\n[0 1 0 0 0 0]\n[0 0 1 0 0 0]\n[1 0 0 0 0 0]\n\nsage: A = C.inverse()*reg(g).matrix()*C;\nsage: view(A, latex=False)\n[                    1                     0                     0                     0                     0                     0]\n[                    0                    -1                     0                     0                     0                     0]\n[                    0                     0                     0  -3/2*I*sqrt(3) - 3/2                     0                     0]\n[                    0                     0 1/2*I*sqrt(1/3) - 1/6                     0                     0                     0]\n[                    0                     0                     0                     0                     0  -3/2*I*sqrt(3) - 3/2]\n[                    0                     0                     0                     0 1/2*I*sqrt(1/3) - 1/6                     0]\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul> Source code in <code>pysymmetry/pysymmetry.py</code> <pre><code>def base_change_matrix(self, right):\n    r\"\"\"\n    Return the basis change matrix associated to a decomposition of right into irreducibles representations.\n\n\n    INPUT:\n\n    - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n    - ``right`` -- representation ; a representation defined over the same group as self.\n\n    OUTPUT: A change basis matrix that decomposes right in its irreducible components.\n\n\n    EXAMPLES:\n\n\n    We define the representation by permutation on the cyclic group of four elements and calculate its decomposition into irreducibles(Note that in this case because multiplicity we get the same result with the isotypic base)  ::\n\n        sage: G = Group(CyclicPermutationGroup(4))\n        sage: generators = G.gens()\n        sage: matrices = [g.matrix() for g in generators]\n        sage: rep = representation(generators, matrices)\n        sage: A = G.base_change_matrix(rep); A\n        [ 1  1  1  1]\n        [ 1 -1  I -I]\n        [ 1  1 -1 -1]\n        [ 1 -1 -I  I]\n\n        sage: [rep(g).matrix() for g in G]\n        [\n        [1 0 0 0]  [0 1 0 0]  [0 0 1 0]  [0 0 0 1]\n        [0 1 0 0]  [0 0 1 0]  [0 0 0 1]  [1 0 0 0]\n        [0 0 1 0]  [0 0 0 1]  [1 0 0 0]  [0 1 0 0]\n        [0 0 0 1], [1 0 0 0], [0 1 0 0], [0 0 1 0]\n        ]\n\n        sage: [A.inverse()*rep(g).matrix()*A for g in G]\n        [\n        [1 0 0 0]  [ 1  0  0  0]  [ 1  0  0  0]  [ 1  0  0  0]\n        [0 1 0 0]  [ 0 -1  0  0]  [ 0  1  0  0]  [ 0 -1  0  0]\n        [0 0 1 0]  [ 0  0  I  0]  [ 0  0 -1  0]  [ 0  0 -I  0]\n        [0 0 0 1], [ 0  0  0 -I], [ 0  0  0 -1], [ 0  0  0  I]\n        ]\n\n\n\n    We define a representation on the group of symmetries of regular hexagon and calculate its matrix change basis to decomposing into irreducible blocks ::\n\n        sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\n        sage: P = matrix([[5,3,4],[0,3,4],[0,0,4]]);P\n        sage: matrices = [P.inverse()*matrix([[1,0,0],[0,1/2,-sqrt(3)/2],[0,sqrt(3)/2,1/2]])*P,P.inverse()*matrix([[1,0,0],[0,-1,0],[0,0,1]])*P];\n        sage: rep = representation(generators, matrices, field=QQbar)\n        sage: G = rep.domain()\n        sage: B = G.base_change_matrix(rep); \n        sage: view(B,latex=False) # This function creates a better visualization of the matrix\n        [        12       -9/5      -54/5]\n        [         0    3*I + 3 -18*I + 18]\n        [         0     -9/4*I     27/2*I]\n\n        sage: [view(rep(g).matrix(), latex=False) for g in G]\n        [\n        [1 0 0]  [                 1               9/10 -2/5*sqrt(3) + 6/5]\n        [0 1 0]  [                 0  1/2*sqrt(3) - 1/2        4*sqrt(1/3)]\n        [0 0 1], [                 0       -3/8*sqrt(3) -1/2*sqrt(3) - 1/2],\n\n        [                 1               9/10  2/5*sqrt(3) + 6/5]\n        [                 0 -1/2*sqrt(3) - 1/2       -4*sqrt(1/3)]\n        [                 0        3/8*sqrt(3)  1/2*sqrt(3) - 1/2],\n\n        [                 1               3/10 -2/5*sqrt(3) + 2/5]\n        [                 0  1/2*sqrt(3) + 1/2        4*sqrt(1/3)]\n        [                 0       -3/8*sqrt(3) -1/2*sqrt(3) + 1/2],\n\n        [  1 6/5 8/5]\n        [  0  -1   0]\n        [  0   0  -1],\n\n        [                 1               3/10  2/5*sqrt(3) + 2/5]\n        [                 0 -1/2*sqrt(3) + 1/2       -4*sqrt(1/3)]\n        [                 0        3/8*sqrt(3)  1/2*sqrt(3) + 1/2],\n\n        [  1   0   0]\n        [  0   1 8/3]\n        [  0   0  -1],\n\n        [                 1               9/10 -2/5*sqrt(3) + 6/5]\n        [                 0 -1/2*sqrt(3) - 1/2               -4/3]\n        [                 0        3/8*sqrt(3)  1/2*sqrt(3) + 1/2],\n\n        [                 1               9/10  2/5*sqrt(3) + 6/5]\n        [                 0  1/2*sqrt(3) - 1/2               -4/3]\n        [                 0       -3/8*sqrt(3) -1/2*sqrt(3) + 1/2],\n\n        [                 1               3/10 -2/5*sqrt(3) + 2/5]\n        [                 0 -1/2*sqrt(3) + 1/2                4/3]\n        [                 0        3/8*sqrt(3)  1/2*sqrt(3) - 1/2],\n\n        [   1  6/5  8/5]\n        [   0   -1 -8/3]\n        [   0    0    1],\n\n        [                 1               3/10  2/5*sqrt(3) + 2/5]\n        [                 0  1/2*sqrt(3) + 1/2                4/3]\n        [                 0       -3/8*sqrt(3) -1/2*sqrt(3) - 1/2]\n        ]\n\n        sage: [view(B.inverse()*rep(g).matrix()*B, latex=False) for g in G]\n        [\n        [1 0 0]\n        [0 1 0]\n        [0 0 1],\n\n        [                   1                    0                    0]\n        [                   0 -1/2*I*sqrt(3) - 1/2                    0]\n        [                   0                    0  1/2*I*sqrt(3) - 1/2],\n\n        [                   1                    0                    0]\n        [                   0  1/2*I*sqrt(3) - 1/2                    0]\n        [                   0                    0 -1/2*I*sqrt(3) - 1/2],\n\n        [                   1                    0                    0]\n        [                   0 -1/2*I*sqrt(3) + 1/2                    0]\n        [                   0                    0  1/2*I*sqrt(3) + 1/2],\n\n        [ 1  0  0]\n        [ 0 -1  0]\n        [ 0  0 -1],\n\n        [                   1                    0                    0]\n        [                   0  1/2*I*sqrt(3) + 1/2                    0]\n        [                   0                    0 -1/2*I*sqrt(3) + 1/2],\n\n        [  1   0   0]  [                      1                       0                       0]\n        [  0   0   6]  [                      0                       0         3*I*sqrt(3) - 3]\n        [  0 1/6   0], [                      0 -1/4*I*sqrt(1/3) - 1/12                       0],\n\n        [                     1                      0                      0]  [                      1                       0                       0]\n        [                     0                      0       -3*I*sqrt(3) - 3]  [                      0                       0         3*I*sqrt(3) + 3]\n        [                     0 1/4*I*sqrt(1/3) - 1/12                      0], [                      0 -1/4*I*sqrt(1/3) + 1/12                       0],\n\n        [   1    0    0]\n        [   0    0   -6]\n        [   0 -1/6    0],\n\n        [                     1                      0                      0]\n        [                     0                      0       -3*I*sqrt(3) + 3]\n        [                     0 1/4*I*sqrt(1/3) + 1/12                      0]\n        ]\n\n\n\n\n    We define the regular representation over the symmetric group of 3 simbols and we decompose into irreducible components ::\n\n        sage: G = Group(SymmetricGroup(3)) \n        sage: reg = G.regular_representation();\n        sage: C = G.base_change_matrix(reg); \n        sage: view(C, latex=False) # This Function creates a better visualization of the matrix\n        [                   1                    1                    1                    0                    0                    3]\n        [                   1                    1  1/2*I*sqrt(3) - 1/2                    0                    0 -3/2*I*sqrt(3) - 3/2]\n        [                   1                    1 -1/2*I*sqrt(3) - 1/2                    0                    0  3/2*I*sqrt(3) - 3/2]\n        [                   1                   -1                    0                    3                    1                    0]\n        [                   1                   -1                    0  3/2*I*sqrt(3) - 3/2 -1/2*I*sqrt(3) - 1/2                    0]\n        [                   1                   -1                    0 -3/2*I*sqrt(3) - 3/2  1/2*I*sqrt(3) - 1/2                    0]\n\n        sage: g = G.an_element();\n        sage: reg(g).matrix()\n        [0 0 0 0 0 1]\n        [0 0 0 1 0 0]\n        [0 0 0 0 1 0]\n        [0 1 0 0 0 0]\n        [0 0 1 0 0 0]\n        [1 0 0 0 0 0]\n\n        sage: A = C.inverse()*reg(g).matrix()*C;\n        sage: view(A, latex=False)\n        [                    1                     0                     0                     0                     0                     0]\n        [                    0                    -1                     0                     0                     0                     0]\n        [                    0                     0                     0  -3/2*I*sqrt(3) - 3/2                     0                     0]\n        [                    0                     0 1/2*I*sqrt(1/3) - 1/6                     0                     0                     0]\n        [                    0                     0                     0                     0                     0  -3/2*I*sqrt(3) - 3/2]\n        [                    0                     0                     0                     0 1/2*I*sqrt(1/3) - 1/6                     0]\n\n\n    REFERENCES:\n\n    For more information, see the following references:\n\n    - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n    - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n    \"\"\"\n\n    #Nota: right pode inclusive ser a irredut\u00edvel????\n    row = 0\n    n, left = self.irreducible_representations(False)  #Nota: vou pensar em como implementar o __len__\n    base = []\n\n    for i in range(n):\n        multiplicity = left(i).inner_product(right) \n        if multiplicity != self.field.zero():  #Nota: acho que aqui \u00e9 um problema em caso de negativa\n            P = self.projection(i, row, 0, right, left)  #Nota: conversar com marcelo a melhor forma de deixar row opcional\n            pivots = P.pivots()\n            for pivot in pivots:\n                v0 = P[:, pivot]\n                degree = left(i).degree()\n                base.append(v0)\n\n                for k in range(1, degree):\n                    v = self.projection(i, row, k, right, left) * v0\n\n                    base.append(v)       \n    b = base[0]\n    for v in base[1:]:\n        b = b.augment(v)  #Nota: verificar de \u00e9 mais edequado. A\u00ed n\u00e3o precisa do numero de colunas\n    #     #base_change_matrix = block_matrix(base, ncols=ncols)\n    return b #IsotypicBase(base)\n</code></pre>"},{"location":"api/#pysymmetry.Group.base_change_matrix_new_off_filter_optimization","title":"<code>base_change_matrix_new_off_filter_optimization(right, row=0)</code>","text":"<p>Return the basis change matrix associated to a symmetry adapted basis to an equivariant operator of right.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- Group ; a  Sage permutation group or a group of the class Group.</li> <li><code>right</code> -- representation ; a representation defined over the same group as self.</li> <li><code>row</code> -- an integer (default: 0) ; an integer in the range of the degree of right, this number will choose the set o projectors to be chosen in the contruction of the base :: </li> </ul> <p>OUTPUT: A change basis matrix that decomposes the equivariant operator.</p> <p>EXAMPLES:</p> <p>We define the representation by permutation on the cyclic group of four elements and decompose an equivariant operator under this representation  ::</p> <pre><code>sage: G = Group(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: A = matrix.circulant([1,2,3,4])\nsage: rep.is_equivariant_to(A)\nTrue\nsage: P = G.base_change_matrix_new_off_filter_optimization(rep); P\n[ 1  1  1  1]\n[ 1 -1  I -I]\n[ 1  1 -1 -1]\n[ 1 -1 -I  I]\nsage: A, P.inverse()*A*P\n(\n[1 2 3 4]  [      10        0        0        0]\n[4 1 2 3]  [       0       -2        0        0]\n[3 4 1 2]  [       0        0 -2*I - 2        0]\n[2 3 4 1], [       0        0        0  2*I - 2]\n)\n</code></pre> <p>We define a representation on the permutation group, and decompose an equivariant operator  ::</p> <pre><code>sage: G = Group(['(2,4)(3,7)(6,8)', '(1,3)(4,6)(7,9)'])\nsage: gens = G.gens()\nsage: matrices = [g.matrix() for g in gens]\nsage: rep = representation(gens, matrices)\nsage: operator = matrix([[ 4, -1, -0, -1, -0, -0, -0, -0, -0],\n                        [-1,  4, -1, -0, -1, -0, -0, -0, -0],\n                        [-0, -1,  4, -0, -0, -1, -0, -0, -0],\n                        [-1, -0, -0,  4, -1, -0, -1, -0, -0],\n                        [-0, -1, -0, -1,  4, -1, -0, -1, -0],\n                        [-0, -0, -1, -0, -1,  4, -0, -0, -1],\n                        [-0, -0, -0, -1, -0, -0,  4, -1, -0],\n                        [-0, -0, -0, -0, -1, -0, -1,  4, -1],\n                        [-0, -0, -0, -0, -0, -1, -0, -1,  4]])\nsage: rep.is_equivariant_to(operator)\nTrue\nsage: P = G.base_change_matrix_new_off_filter_optimization(rep); P\n[ 2  0  0  2  0  2  0  0  0]\n[ 0  2  0  0  2  0  1  0  4]\n[ 2  0  0 -2  0  0  0  8  0]\n[ 0  2  0  0 -2  0  1  0 -4]\n[ 0  0  8  0  0  0  0  0  0]\n[ 0  2  0  0 -2  0 -1  0  4]\n[ 2  0  0 -2  0  0  0 -8  0]\n[ 0  2  0  0  2  0 -1  0 -4]\n[ 2  0  0  2  0 -2  0  0  0]\nsage: operator, P.inverse()*operator*P\n(\n[ 4 -1  0 -1  0  0  0  0  0]  [ 4 -2  0  0  0  0  0  0  0]\n[-1  4 -1  0 -1  0  0  0  0]  [-2  4 -4  0  0  0  0  0  0]\n[ 0 -1  4  0  0 -1  0  0  0]  [ 0 -1  4  0  0  0  0  0  0]\n[-1  0  0  4 -1  0 -1  0  0]  [ 0  0  0  4  0  0  0  0  0]\n[ 0 -1  0 -1  4 -1  0 -1  0]  [ 0  0  0  0  4  0  0  0  0]\n[ 0  0 -1  0 -1  4  0  0 -1]  [ 0  0  0  0  0  4 -1  0  0]\n[ 0  0  0 -1  0  0  4 -1  0]  [ 0  0  0  0  0 -2  4  0  0]\n[ 0  0  0  0 -1  0 -1  4 -1]  [ 0  0  0  0  0  0  0  4 -1]\n[ 0  0  0  0  0 -1  0 -1  4], [ 0  0  0  0  0  0  0 -2  4]\n)\n</code></pre> <p>TO ADD MORE EXAMPLES TO ADD MORE EXAMPLES TO ADD MORE EXAMPLES</p> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul> Source code in <code>pysymmetry/pysymmetry.py</code> <pre><code>def base_change_matrix_new_off_filter_optimization(self, right, row=0):\n    r\"\"\"\n    Return the basis change matrix associated to a symmetry adapted basis to an equivariant operator of right.\n\n\n    INPUT:\n\n    - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n    - ``right`` -- representation ; a representation defined over the same group as self.\n    - ``row`` -- an integer (default: 0) ; an integer in the range of the degree of right, this number will choose the set o projectors to be chosen in the contruction of the base :: \n\n    OUTPUT: A change basis matrix that decomposes the equivariant operator.\n\n\n    EXAMPLES:\n\n\n    We define the representation by permutation on the cyclic group of four elements and decompose an equivariant operator under this representation  ::\n\n        sage: G = Group(CyclicPermutationGroup(4))\n        sage: generators = G.gens()\n        sage: matrices = [g.matrix() for g in generators]\n        sage: rep = representation(generators, matrices)\n        sage: A = matrix.circulant([1,2,3,4])\n        sage: rep.is_equivariant_to(A)\n        True\n        sage: P = G.base_change_matrix_new_off_filter_optimization(rep); P\n        [ 1  1  1  1]\n        [ 1 -1  I -I]\n        [ 1  1 -1 -1]\n        [ 1 -1 -I  I]\n        sage: A, P.inverse()*A*P\n        (\n        [1 2 3 4]  [      10        0        0        0]\n        [4 1 2 3]  [       0       -2        0        0]\n        [3 4 1 2]  [       0        0 -2*I - 2        0]\n        [2 3 4 1], [       0        0        0  2*I - 2]\n        )\n\n\n\n    We define a representation on the permutation group, and decompose an equivariant operator  ::\n\n        sage: G = Group(['(2,4)(3,7)(6,8)', '(1,3)(4,6)(7,9)'])\n        sage: gens = G.gens()\n        sage: matrices = [g.matrix() for g in gens]\n        sage: rep = representation(gens, matrices)\n        sage: operator = matrix([[ 4, -1, -0, -1, -0, -0, -0, -0, -0],\n                                [-1,  4, -1, -0, -1, -0, -0, -0, -0],\n                                [-0, -1,  4, -0, -0, -1, -0, -0, -0],\n                                [-1, -0, -0,  4, -1, -0, -1, -0, -0],\n                                [-0, -1, -0, -1,  4, -1, -0, -1, -0],\n                                [-0, -0, -1, -0, -1,  4, -0, -0, -1],\n                                [-0, -0, -0, -1, -0, -0,  4, -1, -0],\n                                [-0, -0, -0, -0, -1, -0, -1,  4, -1],\n                                [-0, -0, -0, -0, -0, -1, -0, -1,  4]])\n        sage: rep.is_equivariant_to(operator)\n        True\n        sage: P = G.base_change_matrix_new_off_filter_optimization(rep); P\n        [ 2  0  0  2  0  2  0  0  0]\n        [ 0  2  0  0  2  0  1  0  4]\n        [ 2  0  0 -2  0  0  0  8  0]\n        [ 0  2  0  0 -2  0  1  0 -4]\n        [ 0  0  8  0  0  0  0  0  0]\n        [ 0  2  0  0 -2  0 -1  0  4]\n        [ 2  0  0 -2  0  0  0 -8  0]\n        [ 0  2  0  0  2  0 -1  0 -4]\n        [ 2  0  0  2  0 -2  0  0  0]\n        sage: operator, P.inverse()*operator*P\n        (\n        [ 4 -1  0 -1  0  0  0  0  0]  [ 4 -2  0  0  0  0  0  0  0]\n        [-1  4 -1  0 -1  0  0  0  0]  [-2  4 -4  0  0  0  0  0  0]\n        [ 0 -1  4  0  0 -1  0  0  0]  [ 0 -1  4  0  0  0  0  0  0]\n        [-1  0  0  4 -1  0 -1  0  0]  [ 0  0  0  4  0  0  0  0  0]\n        [ 0 -1  0 -1  4 -1  0 -1  0]  [ 0  0  0  0  4  0  0  0  0]\n        [ 0  0 -1  0 -1  4  0  0 -1]  [ 0  0  0  0  0  4 -1  0  0]\n        [ 0  0  0 -1  0  0  4 -1  0]  [ 0  0  0  0  0 -2  4  0  0]\n        [ 0  0  0  0 -1  0 -1  4 -1]  [ 0  0  0  0  0  0  0  4 -1]\n        [ 0  0  0  0  0 -1  0 -1  4], [ 0  0  0  0  0  0  0 -2  4]\n        )\n\n    TO ADD MORE EXAMPLES\n    TO ADD MORE EXAMPLES\n    TO ADD MORE EXAMPLES\n\n\n    REFERENCES:\n\n    For more information, see the following references:\n\n    - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n    - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n    \"\"\"\n    ###Mudar Nome, talvez symmetry_adapted_basis\n    #Nota: right pode inclusive ser a irredut\u00edvel???? PODE\n    n, left = self.irreducible_representations(False)  #Nota: vou pensar em como implementar o __len__\n    base = []\n\n    for i in range(n):\n\n        if left(i).inner_product(right) != self.field.zero():  #Nota: acho que aqui \u00e9 um problema em caso de negativa\n            P = self.projection(i, row, 0, right, left)  #Nota: conversar com marcelo a melhor forma de deixar row opcional. #nota: left???\n            pivots = P.pivots()\n            geracao1 = []\n            for pivot in pivots:\n                v0 = P[:, pivot]\n                geracao1.append(v0)\n            base = base + geracao1 # Nota: Traduzir\n            degree = left(i).degree()\n\n            for k in range(1, degree):  #Nota: Esse laco roda se o range for vazio? Otimizar\n                geracao2 = []\n                for v0 in geracao1:     # Nota: Traduzir\n                    v = self.projection(i, row, k, right, left) * v0\n                    geracao2.append(v)    # Nota: Traduzir\n                base = base + geracao2\n\n    b = base[0]\n    for v in base[1:]:\n        b = b.augment(v)  #Nota: verificar se \u00e9 mais edequado. A\u00ed n\u00e3o precisa do numero de colunas\n        #base_change_matrix = block_matrix(base, ncols=ncols)\n    return b #IsotypicBase(base)\n</code></pre>"},{"location":"api/#pysymmetry.Group.irreducible_representations","title":"<code>irreducible_representations(show_table=True)</code>","text":"<p>Return the number n of irreducible representations of self and the irreducibles representations.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- Group ; a  Sage permutation group or a group of the class Group.</li> <li><code>show_table</code> -- a boolean (default: <code>True</code>) ; shows a table of each irreducible representation applied at the generators of self.</li> </ul> If show_table=True; return number of irreducible representions and irreducible representions themselves. <p>If show_table=False; return the irreducible representions themselves. </p> <p>EXAMPLES:</p> <p>We define the symmetric group of 4 simbols and calculate its irreducible representations ::</p> <pre><code>sage: G = Group(SymmetricGroup(4));\nsage: n, irr = G.irreducible_representations(False) #Irreducible representations\nsage: n\n5\nsage: irr(0)\nMap: \n From: Permutation Group with generators [(1,2), (1,2,3,4)] \n To: Matrix group over Integer Ring with 2 generators ([1], [1]).\n\nsage: irr(4)\nMap: \n From: Permutation Group with generators [(1,2), (1,2,3,4)] \n To: Matrix group over Integer Ring with 2 generators (\n[ 0  1  0]  [ 0  0 -1]\n[ 1  0  0]  [ 0  1  0]\n[ 0  0 -1], [ 1  0  0]\n).\n</code></pre> <p>We define the representation by permutation on the cyclic group calculate its irreducible representations ::</p> <pre><code>sage: G = Group(CyclicPermutationGroup(6))\nsage: irr = G.irreducible_representations(True) #Irreducible representations\n||||||SAIDA A SER PENSADA|||||||\n</code></pre> <p>We calculate the irreducible representations of the group of symmetries of a regular tetrahedron ::</p> <pre><code>sage: G = Group(AlternatingGroup(4));\nsage: irr = G.irreducible_representations(True) #Irreducible representations\nsage: for j in range(n):\n ||||||SAIDA A SER PENSADA|||||||\n</code></pre> <p>We define the group of symmetries of regular hexagon and calculate its irreducible representations  ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: G = Group(PermutationGroup(generators))\nsage: n,irr = G.irreducible_representations(False) #Irreducible representations\nsage: for j in range(n):\n        print(irr(j))\nMap: \n From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n To: Matrix group over Integer Ring with 2 generators ([1], [1]).\nMap: \n From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n To: Matrix group over Integer Ring with 2 generators ([1], [-1]).\nMap: \n From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n To: Matrix group over Integer Ring with 2 generators ([-1], [-1]).\nMap: \n From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n To: Matrix group over Integer Ring with 2 generators ([-1], [1]).\nMap: \n From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n To: Matrix group over Universal Cyclotomic Field with 2 generators (\n[E(3)^2      0]  [0 1]\n[     0   E(3)], [1 0]\n).\nMap: \n From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n To: Matrix group over Universal Cyclotomic Field with 2 generators (\n[-E(3)^2       0]  [ 0 -1]\n[      0   -E(3)], [-1  0]\n).\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul> Source code in <code>pysymmetry/pysymmetry.py</code> <pre><code>def irreducible_representations(self, show_table=True): ##Nota: Como documentar saida com o True\n    r\"\"\"\n    Return the number n of irreducible representations of self and the irreducibles representations.\n\n\n    INPUT:\n\n    - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n    - ``show_table`` -- a boolean (default: `True`) ; shows a table of each irreducible representation applied at the generators of self.\n\n    OUTPUT: If show_table=True; return number of irreducible representions and irreducible representions themselves.\n            If show_table=False; return the irreducible representions themselves. \n\n\n    EXAMPLES:\n\n    We define the symmetric group of 4 simbols and calculate its irreducible representations ::\n\n        sage: G = Group(SymmetricGroup(4));\n        sage: n, irr = G.irreducible_representations(False) #Irreducible representations\n        sage: n\n        5\n        sage: irr(0)\n        Map: \n         From: Permutation Group with generators [(1,2), (1,2,3,4)] \n         To: Matrix group over Integer Ring with 2 generators ([1], [1]).\n\n        sage: irr(4)\n        Map: \n         From: Permutation Group with generators [(1,2), (1,2,3,4)] \n         To: Matrix group over Integer Ring with 2 generators (\n        [ 0  1  0]  [ 0  0 -1]\n        [ 1  0  0]  [ 0  1  0]\n        [ 0  0 -1], [ 1  0  0]\n        ).\n\n    We define the representation by permutation on the cyclic group calculate its irreducible representations ::\n\n        sage: G = Group(CyclicPermutationGroup(6))\n        sage: irr = G.irreducible_representations(True) #Irreducible representations\n        ||||||SAIDA A SER PENSADA|||||||\n\n    We calculate the irreducible representations of the group of symmetries of a regular tetrahedron ::\n\n        sage: G = Group(AlternatingGroup(4));\n        sage: irr = G.irreducible_representations(True) #Irreducible representations\n        sage: for j in range(n):\n         ||||||SAIDA A SER PENSADA|||||||\n\n    We define the group of symmetries of regular hexagon and calculate its irreducible representations  ::\n\n        sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\n        sage: G = Group(PermutationGroup(generators))\n        sage: n,irr = G.irreducible_representations(False) #Irreducible representations\n        sage: for j in range(n):\n                print(irr(j))\n        Map: \n         From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n         To: Matrix group over Integer Ring with 2 generators ([1], [1]).\n        Map: \n         From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n         To: Matrix group over Integer Ring with 2 generators ([1], [-1]).\n        Map: \n         From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n         To: Matrix group over Integer Ring with 2 generators ([-1], [-1]).\n        Map: \n         From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n         To: Matrix group over Integer Ring with 2 generators ([-1], [1]).\n        Map: \n         From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n         To: Matrix group over Universal Cyclotomic Field with 2 generators (\n        [E(3)^2      0]  [0 1]\n        [     0   E(3)], [1 0]\n        ).\n        Map: \n         From: Permutation Group with generators [(1,2,3,4,5,6), (1,4)(2,3)(5,6)] \n         To: Matrix group over Universal Cyclotomic Field with 2 generators (\n        [-E(3)^2       0]  [ 0 -1]\n        [      0   -E(3)], [-1  0]\n        ).\n\n    REFERENCES:\n\n    For more information, see the following references:\n\n    - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n    - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n    \"\"\"\n\n\n    irr = gap.IrreducibleRepresentations(self)\n    gens = gap.GeneratorsOfGroup(self)\n    generators = list(gap.List(gens))\n    matrices_list = []\n    for s in irr:\n        matrices = [\n                matrix(sage_eval(str(gap.Image(s, k)))) for k in generators\n                ]\n        matrices_list.append(matrices)\n\n    def irr_rep(n):            \n        r = representation(generators, matrices_list[n], self.field)\n        return r\n\n    N = len(matrices_list)\n    if show_table:\n\n        n = self.ngens()\n        elements = self.gens()\n\n        matrices_rep = [\n            view((irr_rep(k)(x)).matrix(), False) for k in range(N)\n            for x in elements\n                    ]\n        _table = [matrices_rep[i:i + n] for i in range(0, len(matrices_rep), n)]\n        header_row = [str(x) for x in elements]\n        header_column = [''.join(('$r^', str(k), '$')) for k in range(N)]\n        header_column.insert(0, ' ')\n\n        t = table(_table,\n                  header_row=header_row,\n                  header_column=header_column,\n                  align='center')\n        show(t)\n\n        return irr_rep\n\n    return N, irr_rep\n</code></pre>"},{"location":"api/#pysymmetry.Group.isotypic_base","title":"<code>isotypic_base(rep, isotypic_components=False)</code>","text":"<p>Return a list with the basis for each isotypic components of rep or the basis change matrix associated to the isotypic decomposition.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- Group ; a  Sage permutation group or a group of the class Group.</li> <li><code>rep</code> -- representation ; a representation defined over the same group as self.</li> <li><code>isotypic_components</code> -- a boolean (default: <code>False</code>) ; if False returns the change base matrix, if True returns a list with a base for each isotypic component :: </li> </ul> <p>OUTPUT: A list with a basis for each isotypic subspace of rep or the change basis matrix to a form in blocks associated to isotypic components of rep.</p> <p>EXAMPLES:</p> <p>We define the symmetric group of 3 simbols change basis matrix associated to the isotypic decomposition  ::</p> <pre><code>sage: G = Group(SymmetricGroup(3));\nsage: reg = G.regular_representation();\nsage: G.isotypic_base(reg, isotypic_components=False)\n[ 1| 1| 2 -1  0  0]\n[ 1| 1|-1  2  0  0]\n[ 1| 1|-1 -1  0  0]\n[ 1|-1| 0  0  2 -1]\n[ 1|-1| 0  0 -1  2]\n[ 1|-1| 0  0 -1 -1]\n</code></pre> <p>The isotypic basis for each irreducible subspace associated to the regular representation of this group ::</p> <pre><code>sage: G.isotypic_base(reg, isotypic_components=True)\n[\n[1]  [ 1]  [ 2 -1  0  0]\n[1]  [ 1]  [-1  2  0  0]\n[1]  [ 1]  [-1 -1  0  0]\n[1]  [-1]  [ 0  0  2 -1]\n[1]  [-1]  [ 0  0 -1  2]\n[1], [-1], [ 0  0 -1 -1]\n]\n</code></pre> <p>We define the representation by permutation on the cyclic group and calculate its isotypic decompositions ::</p> <pre><code>sage: G = Group(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: G.isotypic_base(rep, isotypic_components=True)\n[\n[1]  [ 1]  [   1]  [   1]\n[1]  [-1]  [ 1*I]  [-1*I]\n[1]  [ 1]  [  -1]  [  -1]\n[1], [-1], [-1*I], [ 1*I]\n]\n\nsage: change_basis = G.isotypic_base(rep, isotypic_components=False); change_basis\n[   1|   1|   1|   1]\n[   1|  -1| 1*I|-1*I]\n[   1|   1|  -1|  -1]\n[   1|  -1|-1*I| 1*I]\nsage: [rep(g).matrix() for g in G]\n[\n[1 0 0 0]  [0 1 0 0]  [0 0 1 0]  [0 0 0 1]\n[0 1 0 0]  [0 0 1 0]  [0 0 0 1]  [1 0 0 0]\n[0 0 1 0]  [0 0 0 1]  [1 0 0 0]  [0 1 0 0]\n[0 0 0 1], [1 0 0 0], [0 1 0 0], [0 0 1 0]\n]\nsage: [change_basis.inverse()*rep(g).matrix()*change_basis for g in G]\n[\n[1 0 0 0]  [   1    0    0    0]  [ 1  0  0  0]  [   1    0    0    0]\n[0 1 0 0]  [   0   -1    0    0]  [ 0  1  0  0]  [   0   -1    0    0]\n[0 0 1 0]  [   0    0  1*I    0]  [ 0  0 -1  0]  [   0    0 -1*I    0]\n[0 0 0 1], [   0    0    0 -1*I], [ 0  0  0 -1], [   0    0    0  1*I]\n]\n</code></pre> <p>We define a representation the group of symmetries of regular hexagon and calculate their matrix change basis(this representation is irreducible) ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: matrices = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])];\nsage: rep = representation(generators, matrices)\nsage: G = rep.domain()\nsage: G.isotypic_base(rep, isotypic_components=True)\n[\n[6 0]\n[0 6]\n]\n</code></pre> <p>TO ADD MORE EXAMPLES TO ADD MORE EXAMPLES TO ADD MORE EXAMPLES</p> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul> Source code in <code>pysymmetry/pysymmetry.py</code> <pre><code>def isotypic_base(self, rep, isotypic_components=False):\n    r\"\"\"\n    Return a list with the basis for each isotypic components of rep or the basis change matrix associated to the isotypic decomposition.\n\n\n    INPUT:\n\n    - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n    - ``rep`` -- representation ; a representation defined over the same group as self.\n    - ``isotypic_components`` -- a boolean (default: `False`) ; if False returns the change base matrix, if True returns a list with a base for each isotypic component :: \n\n    OUTPUT: A list with a basis for each isotypic subspace of rep or the change basis matrix to a form in blocks associated to isotypic components of rep.\n\n\n    EXAMPLES:\n\n    We define the symmetric group of 3 simbols change basis matrix associated to the isotypic decomposition  ::\n\n        sage: G = Group(SymmetricGroup(3));\n        sage: reg = G.regular_representation();\n        sage: G.isotypic_base(reg, isotypic_components=False)\n        [ 1| 1| 2 -1  0  0]\n        [ 1| 1|-1  2  0  0]\n        [ 1| 1|-1 -1  0  0]\n        [ 1|-1| 0  0  2 -1]\n        [ 1|-1| 0  0 -1  2]\n        [ 1|-1| 0  0 -1 -1]\n\n\n    The isotypic basis for each irreducible subspace associated to the regular representation of this group ::\n\n        sage: G.isotypic_base(reg, isotypic_components=True)\n        [\n        [1]  [ 1]  [ 2 -1  0  0]\n        [1]  [ 1]  [-1  2  0  0]\n        [1]  [ 1]  [-1 -1  0  0]\n        [1]  [-1]  [ 0  0  2 -1]\n        [1]  [-1]  [ 0  0 -1  2]\n        [1], [-1], [ 0  0 -1 -1]\n        ]\n\n    We define the representation by permutation on the cyclic group and calculate its isotypic decompositions ::\n\n        sage: G = Group(CyclicPermutationGroup(4))\n        sage: generators = G.gens()\n        sage: matrices = [g.matrix() for g in generators]\n        sage: rep = representation(generators, matrices)\n        sage: G.isotypic_base(rep, isotypic_components=True)\n        [\n        [1]  [ 1]  [   1]  [   1]\n        [1]  [-1]  [ 1*I]  [-1*I]\n        [1]  [ 1]  [  -1]  [  -1]\n        [1], [-1], [-1*I], [ 1*I]\n        ]\n\n        sage: change_basis = G.isotypic_base(rep, isotypic_components=False); change_basis\n        [   1|   1|   1|   1]\n        [   1|  -1| 1*I|-1*I]\n        [   1|   1|  -1|  -1]\n        [   1|  -1|-1*I| 1*I]\n        sage: [rep(g).matrix() for g in G]\n        [\n        [1 0 0 0]  [0 1 0 0]  [0 0 1 0]  [0 0 0 1]\n        [0 1 0 0]  [0 0 1 0]  [0 0 0 1]  [1 0 0 0]\n        [0 0 1 0]  [0 0 0 1]  [1 0 0 0]  [0 1 0 0]\n        [0 0 0 1], [1 0 0 0], [0 1 0 0], [0 0 1 0]\n        ]\n        sage: [change_basis.inverse()*rep(g).matrix()*change_basis for g in G]\n        [\n        [1 0 0 0]  [   1    0    0    0]  [ 1  0  0  0]  [   1    0    0    0]\n        [0 1 0 0]  [   0   -1    0    0]  [ 0  1  0  0]  [   0   -1    0    0]\n        [0 0 1 0]  [   0    0  1*I    0]  [ 0  0 -1  0]  [   0    0 -1*I    0]\n        [0 0 0 1], [   0    0    0 -1*I], [ 0  0  0 -1], [   0    0    0  1*I]\n        ]\n\n    We define a representation the group of symmetries of regular hexagon and calculate their matrix change basis(this representation is irreducible) ::\n\n        sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\n        sage: matrices = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])];\n        sage: rep = representation(generators, matrices)\n        sage: G = rep.domain()\n        sage: G.isotypic_base(rep, isotypic_components=True)\n        [\n        [6 0]\n        [0 6]\n        ]\n\n\n    TO ADD MORE EXAMPLES\n    TO ADD MORE EXAMPLES\n    TO ADD MORE EXAMPLES\n\n    REFERENCES:\n\n    For more information, see the following references:\n\n    - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n    - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n    \"\"\"\n    proj_lst = self.isotypic_projection(rep)  #NOTA:devemos usar sempre regular representation(pergunta)??? NAO\n    decomposition = [m.matrix_from_columns(m.pivots()) for m in proj_lst]\n    if isotypic_components:\n        return decomposition\n    ncols = len(decomposition)\n    return block_matrix(decomposition, ncols=ncols)\n</code></pre>"},{"location":"api/#pysymmetry.Group.isotypic_projection","title":"<code>isotypic_projection(right)</code>","text":"<p>Return a list containing the matrices associated to projections operators over the isotypic components(or conglomerates) of right.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- Group ; a  Sage permutation group or a group of the class Group.</li> <li><code>right</code> -- representation ; a representation defined over the same group as self.</li> </ul> <p>OUTPUT: A list of matrices representing the projections operators over the isotypics subespaces of right.</p> <p>EXAMPLES:</p> <p>We define the symmetric group of 3 simbols and the isotypic projections associated to the regular representation of this group ::</p> <pre><code>sage: G = Group(SymmetricGroup(3));\nsage: reg = G.regular_representation();\nsage: G.isotypic_projection(reg)\n [\n [1 1 1 1 1 1]  [ 1  1  1 -1 -1 -1]  [ 2 -1 -1  0  0  0]\n [1 1 1 1 1 1]  [ 1  1  1 -1 -1 -1]  [-1  2 -1  0  0  0]\n [1 1 1 1 1 1]  [ 1  1  1 -1 -1 -1]  [-1 -1  2  0  0  0]\n [1 1 1 1 1 1]  [-1 -1 -1  1  1  1]  [ 0  0  0  2 -1 -1]\n [1 1 1 1 1 1]  [-1 -1 -1  1  1  1]  [ 0  0  0 -1  2 -1]\n [1 1 1 1 1 1], [-1 -1 -1  1  1  1], [ 0  0  0 -1 -1  2]\n  ]\n</code></pre> <p>We calculate an irreducible representation of G, and the isotypic projection associated ::</p> <pre><code>sage: n,irr = G.irreducible_representations(False) #Irreducible representations\nsage: G.isotypic_projection(irr(2))\n[\n[3 0]\n[0 3]\n]\n</code></pre> <p>We define the representation by permutation on the cyclic group and calculate the isotypic projectors ::</p> <pre><code>sage: G = Group(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: G.isotypic_projection(rep)\n[\n[1 1 1 1]  [ 1 -1  1 -1]  [   1 -1*I   -1  1*I]  [   1  1*I   -1 -1*I]\n[1 1 1 1]  [-1  1 -1  1]  [ 1*I    1 -1*I   -1]  [-1*I    1  1*I   -1]\n[1 1 1 1]  [ 1 -1  1 -1]  [  -1  1*I    1 -1*I]  [  -1 -1*I    1  1*I]\n[1 1 1 1], [-1  1 -1  1], [-1*I   -1  1*I    1], [ 1*I   -1 -1*I    1]\n]\n</code></pre> <p>We define a representation the group of symmetries of regular hexagon and calculate their isotypic projectors ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: rotation_pi_over_3, reflexion_about_x = matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])\nsage: matrices = [block_diagonal_matrix(rotation_pi_over_3, rotation_pi_over_3),block_diagonal_matrix(reflexion_about_x, reflexion_about_x)];\nsage: rep = representation(generators, matrices, field=SR)\nsage: G = rep.domain()\nsage: G.isotypic_projection(rep)\n[\n[6 0 0 0]\n[0 6 0 0]\n[0 0 6 0]\n[0 0 0 6]\n]\n</code></pre> <p>TO ADD MORE EXAMPLES TO ADD MORE EXAMPLES TO ADD MORE EXAMPLES</p> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul> Source code in <code>pysymmetry/pysymmetry.py</code> <pre><code>def isotypic_projection(self, right):\n    r\"\"\"\n    Return a list containing the matrices associated to projections operators over the isotypic components(or conglomerates) of right.\n\n\n    INPUT:\n\n    - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n    - ``right`` -- representation ; a representation defined over the same group as self.\n\n    OUTPUT: A list of matrices representing the projections operators over the isotypics subespaces of right.\n\n\n    EXAMPLES:\n\n    We define the symmetric group of 3 simbols and the isotypic projections associated to the regular representation of this group ::\n\n        sage: G = Group(SymmetricGroup(3));\n        sage: reg = G.regular_representation();\n        sage: G.isotypic_projection(reg)\n         [\n         [1 1 1 1 1 1]  [ 1  1  1 -1 -1 -1]  [ 2 -1 -1  0  0  0]\n         [1 1 1 1 1 1]  [ 1  1  1 -1 -1 -1]  [-1  2 -1  0  0  0]\n         [1 1 1 1 1 1]  [ 1  1  1 -1 -1 -1]  [-1 -1  2  0  0  0]\n         [1 1 1 1 1 1]  [-1 -1 -1  1  1  1]  [ 0  0  0  2 -1 -1]\n         [1 1 1 1 1 1]  [-1 -1 -1  1  1  1]  [ 0  0  0 -1  2 -1]\n         [1 1 1 1 1 1], [-1 -1 -1  1  1  1], [ 0  0  0 -1 -1  2]\n          ]\n\n    We calculate an irreducible representation of G, and the isotypic projection associated ::\n\n        sage: n,irr = G.irreducible_representations(False) #Irreducible representations\n        sage: G.isotypic_projection(irr(2))\n        [\n        [3 0]\n        [0 3]\n        ]\n\n\n    We define the representation by permutation on the cyclic group and calculate the isotypic projectors ::\n\n        sage: G = Group(CyclicPermutationGroup(4))\n        sage: generators = G.gens()\n        sage: matrices = [g.matrix() for g in generators]\n        sage: rep = representation(generators, matrices)\n        sage: G.isotypic_projection(rep)\n        [\n        [1 1 1 1]  [ 1 -1  1 -1]  [   1 -1*I   -1  1*I]  [   1  1*I   -1 -1*I]\n        [1 1 1 1]  [-1  1 -1  1]  [ 1*I    1 -1*I   -1]  [-1*I    1  1*I   -1]\n        [1 1 1 1]  [ 1 -1  1 -1]  [  -1  1*I    1 -1*I]  [  -1 -1*I    1  1*I]\n        [1 1 1 1], [-1  1 -1  1], [-1*I   -1  1*I    1], [ 1*I   -1 -1*I    1]\n        ]\n\n\n    We define a representation the group of symmetries of regular hexagon and calculate their isotypic projectors ::\n\n        sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\n        sage: rotation_pi_over_3, reflexion_about_x = matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])\n        sage: matrices = [block_diagonal_matrix(rotation_pi_over_3, rotation_pi_over_3),block_diagonal_matrix(reflexion_about_x, reflexion_about_x)];\n        sage: rep = representation(generators, matrices, field=SR)\n        sage: G = rep.domain()\n        sage: G.isotypic_projection(rep)\n        [\n        [6 0 0 0]\n        [0 6 0 0]\n        [0 0 6 0]\n        [0 0 0 6]\n        ]\n\n    TO ADD MORE EXAMPLES\n    TO ADD MORE EXAMPLES\n    TO ADD MORE EXAMPLES\n\n    REFERENCES:\n\n    For more information, see the following references:\n\n    - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n    - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n    \"\"\"\n    n, left = self.irreducible_representations(False)\n    proj_lst = []\n    for i in range(n):\n        if left(i).inner_product(right) != self.field.zero():\n            s = sum([conjugate(left(i)(g).character())*right(g).matrix()  for g in self])\n            proj_lst.append(s)\n\n    return proj_lst\n</code></pre>"},{"location":"api/#pysymmetry.Group.projection","title":"<code>projection(i, j, k, right, left=None)</code>","text":"<p>Return the projection(or transfers operators) associated to irreducible subrepresentations of right.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- Group ; a  Sage permutation group or a group of the class Group.</li> <li><code>right</code> -- representation ; a representation defined over the same group as self.</li> <li><code>i,j,k</code> --  integers ; integers numbers representing the projection(or transfer) chosen;         i- will choose the irreducible representation, and its range is from 0 until the number of irreducibles. ::<pre><code>j- choose a row of the matrix presentation of the irreducible, its range is the degree of chosen irreducible according i. ::\n\nk- choose a column of the matrix presentation of the irreducible, its range is the degree of chosen irreducible according i. ::\n</code></pre> </li> </ul> A matrix associated to the operator that projects over an irreducible subrepresentation of right(if j=k), or is a isomorphism between two equivalent subrepresentations of right. <p>Whenever the irreducible, chosen by index i, it is not a subrepresentation of right this matrix will be null.</p> <p>EXAMPLES:</p> <p>We define the representation by permutation on the cyclic group of four elements and calculate its projectors  ::</p> <pre><code>sage: G = Group(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: G.projection(0,0,0, rep)\n[1 1 1 1]\n[1 1 1 1]\n[1 1 1 1]\n[1 1 1 1]\nsage: n, irr = G.irreducible_representations(False)\nsage: list_of_projectors=[];\nfor i in range(n): # Choosing the irreducible\n    degree= irr(i).degree() # Calculation the degree of the irreducible\n    j=0;# we will use the first row\n    for k in range(degree):\n        projector = G.projection(i,j,k, rep);\n        list_of_projectors.append(projector)\nsage: list_of_projectors\n[\n[1 1 1 1]  [ 1 -1  1 -1]  [ 1 -I -1  I]  [ 1  I -1 -I]\n[1 1 1 1]  [-1  1 -1  1]  [ I  1 -I -1]  [-I  1  I -1]\n[1 1 1 1]  [ 1 -1  1 -1]  [-1  I  1 -I]  [-1 -I  1  I]\n[1 1 1 1], [-1  1 -1  1], [-I -1  I  1], [ I -1 -I  1]\n]\n</code></pre> <p>We define a representation on the group of symmetries of regular hexagon and calculate its projectors ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: matrices = [matrix([[1,0,0],[0,1/2,-sqrt(3)/2],[0,sqrt(3)/2,1/2]]),matrix([[1,0,0],[0,-1,0],[0,0,1]])];\nsage: rep = representation(generators, matrices)\nsage: G = rep.domain()\nsage: G.projection(0,0,0, rep)\n[     12       0       0]\n[      0       0 0.?e-18]\n[      0 0.?e-18       0]\nsage: n, irr = G.irreducible_representations(False)\nsage: list_of_projectors=[];\nfor i in range(n): # Choosing the irreducible\n    degree= irr(i).degree() # Calculation the degree of the irreducible\n    j=0;# we will use the first row\n    for k in range(degree):\n        projector = G.projection(i,j,k, rep);\n        list_of_projectors.append(view(projector, latex=False)) # view creates a better visualization\nsage: list_of_projectors\n[\n[12  0  0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]\n[ 0  0  0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]\n[ 0  0  0], [0 0 0], [0 0 0], [0 0 0], [0 0 0], [0 0 0],\n\n[   0    0    0]  [  0   0   0]\n[   0    3  3*I]  [  0   3 3*I]\n[   0 -3*I    3], [  0 3*I  -3]\n]\n</code></pre> <p>We define the regular representation over the symmetric group of 3 simbols and we calculate one of its projectors ::</p> <pre><code>sage: G = Group(SymmetricGroup(3)) \nsage: reg = G.regular_representation();\nsage: view(G.projection(2,1,1, reg),latex=False) # The function view creates a better visualization\n[                   1  1/2*I*sqrt(3) - 1/2 -1/2*I*sqrt(3) - 1/2                    0                    0                    0]\n[-1/2*I*sqrt(3) - 1/2                    1  1/2*I*sqrt(3) - 1/2                    0                    0                    0]\n[ 1/2*I*sqrt(3) - 1/2 -1/2*I*sqrt(3) - 1/2                    1                    0                    0                    0]\n[                   0                    0                    0                    1 -1/2*I*sqrt(3) - 1/2  1/2*I*sqrt(3) - 1/2]\n[                   0                    0                    0  1/2*I*sqrt(3) - 1/2                    1 -1/2*I*sqrt(3) - 1/2]\n[                   0                    0                    0 -1/2*I*sqrt(3) - 1/2  1/2*I*sqrt(3) - 1/2                    1]\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul> Source code in <code>pysymmetry/pysymmetry.py</code> <pre><code>def projection(self, i, j, k, right, left=None):\n    r\"\"\"\n    Return the projection(or transfers operators) associated to irreducible subrepresentations of right.\n\n    INPUT:\n\n    - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n    - ``right`` -- representation ; a representation defined over the same group as self.\n    - ``i,j,k`` --  integers ; integers numbers representing the projection(or transfer) chosen;\n            i- will choose the irreducible representation, and its range is from 0 until the number of irreducibles. ::\n\n            j- choose a row of the matrix presentation of the irreducible, its range is the degree of chosen irreducible according i. ::\n\n            k- choose a column of the matrix presentation of the irreducible, its range is the degree of chosen irreducible according i. ::\n\n\n    OUTPUT: A matrix associated to the operator that projects over an irreducible subrepresentation of right(if j=k), or is a isomorphism between two equivalent subrepresentations of right.\n            Whenever the irreducible, chosen by index i, it is not a subrepresentation of right this matrix will be null.\n\n\n    EXAMPLES:\n\n\n    We define the representation by permutation on the cyclic group of four elements and calculate its projectors  ::\n\n        sage: G = Group(CyclicPermutationGroup(4))\n        sage: generators = G.gens()\n        sage: matrices = [g.matrix() for g in generators]\n        sage: rep = representation(generators, matrices)\n        sage: G.projection(0,0,0, rep)\n        [1 1 1 1]\n        [1 1 1 1]\n        [1 1 1 1]\n        [1 1 1 1]\n        sage: n, irr = G.irreducible_representations(False)\n        sage: list_of_projectors=[];\n        for i in range(n): # Choosing the irreducible\n            degree= irr(i).degree() # Calculation the degree of the irreducible\n            j=0;# we will use the first row\n            for k in range(degree):\n                projector = G.projection(i,j,k, rep);\n                list_of_projectors.append(projector)\n        sage: list_of_projectors\n        [\n        [1 1 1 1]  [ 1 -1  1 -1]  [ 1 -I -1  I]  [ 1  I -1 -I]\n        [1 1 1 1]  [-1  1 -1  1]  [ I  1 -I -1]  [-I  1  I -1]\n        [1 1 1 1]  [ 1 -1  1 -1]  [-1  I  1 -I]  [-1 -I  1  I]\n        [1 1 1 1], [-1  1 -1  1], [-I -1  I  1], [ I -1 -I  1]\n        ]\n\n\n    We define a representation on the group of symmetries of regular hexagon and calculate its projectors ::\n\n        sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\n        sage: matrices = [matrix([[1,0,0],[0,1/2,-sqrt(3)/2],[0,sqrt(3)/2,1/2]]),matrix([[1,0,0],[0,-1,0],[0,0,1]])];\n        sage: rep = representation(generators, matrices)\n        sage: G = rep.domain()\n        sage: G.projection(0,0,0, rep)\n        [     12       0       0]\n        [      0       0 0.?e-18]\n        [      0 0.?e-18       0]\n        sage: n, irr = G.irreducible_representations(False)\n        sage: list_of_projectors=[];\n        for i in range(n): # Choosing the irreducible\n            degree= irr(i).degree() # Calculation the degree of the irreducible\n            j=0;# we will use the first row\n            for k in range(degree):\n                projector = G.projection(i,j,k, rep);\n                list_of_projectors.append(view(projector, latex=False)) # view creates a better visualization\n        sage: list_of_projectors\n        [\n        [12  0  0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]\n        [ 0  0  0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]  [0 0 0]\n        [ 0  0  0], [0 0 0], [0 0 0], [0 0 0], [0 0 0], [0 0 0],\n\n        [   0    0    0]  [  0   0   0]\n        [   0    3  3*I]  [  0   3 3*I]\n        [   0 -3*I    3], [  0 3*I  -3]\n        ]\n\n\n    We define the regular representation over the symmetric group of 3 simbols and we calculate one of its projectors ::\n\n        sage: G = Group(SymmetricGroup(3)) \n        sage: reg = G.regular_representation();\n        sage: view(G.projection(2,1,1, reg),latex=False) # The function view creates a better visualization\n        [                   1  1/2*I*sqrt(3) - 1/2 -1/2*I*sqrt(3) - 1/2                    0                    0                    0]\n        [-1/2*I*sqrt(3) - 1/2                    1  1/2*I*sqrt(3) - 1/2                    0                    0                    0]\n        [ 1/2*I*sqrt(3) - 1/2 -1/2*I*sqrt(3) - 1/2                    1                    0                    0                    0]\n        [                   0                    0                    0                    1 -1/2*I*sqrt(3) - 1/2  1/2*I*sqrt(3) - 1/2]\n        [                   0                    0                    0  1/2*I*sqrt(3) - 1/2                    1 -1/2*I*sqrt(3) - 1/2]\n        [                   0                    0                    0 -1/2*I*sqrt(3) - 1/2  1/2*I*sqrt(3) - 1/2                    1]\n\n    REFERENCES:\n\n    For more information, see the following references:\n\n    - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n    - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n    \"\"\"\n\n\n    #Nota:   ver como melhorar a posi\u00e7\u00e3o do left\n    #Nota: right pode inclusive ser a irredutivel (pergunta)\n    ###Melhorar este nome opcoes: transfer isomorphism \n    if left == None:\n        n, left = self.irreducible_representations(False)\n    s = sum([matrix(left(i)(g.inverse()))[j][k] * matrix(right(g)) for g in self])  #Nota:\n    return s\n</code></pre>"},{"location":"api/#pysymmetry.Group.quick_block_prevision","title":"<code>quick_block_prevision(right, block_prevision=False)</code>","text":"<p>Return a list with order and multiplicities of blocks to an equivariant operator under right defined on self.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- Group ; a  Sage permutation group or a group of the class Group.</li> <li><code>right</code> -- representation ; a representation defined over an arbitrary group given by self.</li> <li><code>block_prevision</code> -- a boolean (default: <code>False</code>) ; if set to True then prints a string describing the number and orders of blocks to an equivariant operator under right.</li> </ul> <p>OUTPUT: A list indicating the degree and multiplicity of the representation defined by right. </p> <p>EXAMPLES:</p> <p>We define the regular representation(reg) over the symmetric group of 4 simbols and calculate the structure of an equivariant operator under reg ::</p> <pre><code>sage: H = SymmetricGroup(4)\nsage: G = Group(H);\nsage: reg = G.regular_representation();\nsage: G.quick_block_prevision(reg)\n[['degree', 'multiplicity'], [1, 1], [1, 1], [2, 2], [3, 3], [3, 3]]\n\nsage: G.quick_block_prevision(reg, block_prevision=True)\n1 block size 1x1\n1 block size 1x1\n2 block size 2x2\n3 block size 3x3\n3 block size 3x3\n[['degree', 'multiplicity'], [1, 1], [1, 1], [2, 2], [3, 3], [3, 3]]\n</code></pre> <p>We define the representation by permutation on the cyclic group and calculate the structure of an equivariant operator ::</p> <pre><code>sage: G = Group(CyclicPermutationGroup(4))\nsage: generators = G.gens()\nsage: matrices = [g.matrix() for g in generators]\nsage: rep = representation(generators, matrices)\nsage: G.quick_block_prevision(rep, block_prevision=True)\n1 block size 1x1\n1 block size 1x1\n1 block size 1x1\n1 block size 1x1\n[['degree', 'multiplicity'], [1, 1], [1, 1], [1, 1], [1, 1]]\n</code></pre> <p>We calculate the irreducible representations of the group of symmetries of tetrahedron and calculate the structure of an equivariant operator inder its irreducibles ::</p> <pre><code>sage: G = Group(AlternatingGroup(4));\nsage: n,irr = G.irreducible_representations(False) ##Irreducible representations\nsage: for j in range(n):\n        print(G.quick_block_prevision(irr(j),block_prevision=True))\n1 block size 1x1\n[['degree', 'multiplicity'], [1, 1]]\n1 block size 1x1\n[['degree', 'multiplicity'], [1, 1]]\n1 block size 1x1\n[['degree', 'multiplicity'], [1, 1]]\n3 block size 1x1\n[['degree', 'multiplicity'], [3, 1]]\n</code></pre> <p>We define two representation rep and rep1 on the group of symmetries of regular hexagon and calculate the structure of an equivariant operator under each one ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: matrices = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])];\nsage: rep = representation(generators, matrices)\nsage: G = rep.domain()\nsage: G.quick_block_prevision(rep,block_prevision=True)\n2 block size 1x1\n[['degree', 'multiplicity'], [2, 1]]\n\nsage: P = matrix([[2,1],[15,2]]); #A change of basis\nsage: matrices1 = [ block_diagonal_matrix((P.inverse())*A*P, (P.inverse())*A*P) for A in matrices];\nsage: rep1 = representation(generators, matrices1)\nsage: G.quick_block_prevision(rep1,block_prevision=True)\n2 block size 2x2\n[['degree', 'multiplicity'], [2, 2]]\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul> Source code in <code>pysymmetry/pysymmetry.py</code> <pre><code>def quick_block_prevision(self, right, block_prevision=False):##Nota, consertar row ##Revisar a documentacao do True or False\n    r\"\"\"\n    Return a list with order and multiplicities of blocks to an equivariant operator under right defined on self.\n\n    INPUT:\n\n    - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n    - ``right`` -- representation ; a representation defined over an arbitrary group given by self.\n    - ``block_prevision`` -- a boolean (default: `False`) ; if set to True then prints a string describing the number and orders of blocks to an equivariant operator under right.\n\n    OUTPUT: A list indicating the degree and multiplicity of the representation defined by right. \n\n\n    EXAMPLES:\n\n    We define the regular representation(reg) over the symmetric group of 4 simbols and calculate the structure of an equivariant operator under reg ::\n\n        sage: H = SymmetricGroup(4)\n        sage: G = Group(H);\n        sage: reg = G.regular_representation();\n        sage: G.quick_block_prevision(reg)\n        [['degree', 'multiplicity'], [1, 1], [1, 1], [2, 2], [3, 3], [3, 3]]\n\n        sage: G.quick_block_prevision(reg, block_prevision=True)\n        1 block size 1x1\n        1 block size 1x1\n        2 block size 2x2\n        3 block size 3x3\n        3 block size 3x3\n        [['degree', 'multiplicity'], [1, 1], [1, 1], [2, 2], [3, 3], [3, 3]]\n\n    We define the representation by permutation on the cyclic group and calculate the structure of an equivariant operator ::\n\n        sage: G = Group(CyclicPermutationGroup(4))\n        sage: generators = G.gens()\n        sage: matrices = [g.matrix() for g in generators]\n        sage: rep = representation(generators, matrices)\n        sage: G.quick_block_prevision(rep, block_prevision=True)\n        1 block size 1x1\n        1 block size 1x1\n        1 block size 1x1\n        1 block size 1x1\n        [['degree', 'multiplicity'], [1, 1], [1, 1], [1, 1], [1, 1]]\n\n    We calculate the irreducible representations of the group of symmetries of tetrahedron and calculate the structure of an equivariant operator inder its irreducibles ::\n\n        sage: G = Group(AlternatingGroup(4));\n        sage: n,irr = G.irreducible_representations(False) ##Irreducible representations\n        sage: for j in range(n):\n                print(G.quick_block_prevision(irr(j),block_prevision=True))\n        1 block size 1x1\n        [['degree', 'multiplicity'], [1, 1]]\n        1 block size 1x1\n        [['degree', 'multiplicity'], [1, 1]]\n        1 block size 1x1\n        [['degree', 'multiplicity'], [1, 1]]\n        3 block size 1x1\n        [['degree', 'multiplicity'], [3, 1]]\n\n\n\n    We define two representation rep and rep1 on the group of symmetries of regular hexagon and calculate the structure of an equivariant operator under each one ::\n\n        sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\n        sage: matrices = [matrix([[1/2,-sqrt(3)/2],[sqrt(3)/2,1/2]]),matrix([[-1,0],[0,1]])];\n        sage: rep = representation(generators, matrices)\n        sage: G = rep.domain()\n        sage: G.quick_block_prevision(rep,block_prevision=True)\n        2 block size 1x1\n        [['degree', 'multiplicity'], [2, 1]]\n\n        sage: P = matrix([[2,1],[15,2]]); #A change of basis\n        sage: matrices1 = [ block_diagonal_matrix((P.inverse())*A*P, (P.inverse())*A*P) for A in matrices];\n        sage: rep1 = representation(generators, matrices1)\n        sage: G.quick_block_prevision(rep1,block_prevision=True)\n        2 block size 2x2\n        [['degree', 'multiplicity'], [2, 2]]\n\n\n    REFERENCES:\n\n    For more information, see the following references:\n\n    - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n    - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n    \"\"\"        \n    n, left = self.irreducible_representations(False) \n\n    info = [['degree', 'multiplicity']]        \n    for i in range(n):\n    \tmultiplicity = left(i).inner_product(right)\n    \ttry:\n    \t\tmultiplicity = multiplicity.radical_expression()\n    \texcept: AttributeError\n    \tif multiplicity != self.field.zero():\n    \t\tdegree = left(i).degree()\n    \t\tinfo.append([degree, multiplicity])\n    if block_prevision:\n    \tfor k in info[1:]:\n    \t\tprint(str(k[0]) + ' block size ' + str(k[1]) + 'x' + str(k[1]) )\n    return info\n</code></pre>"},{"location":"api/#pysymmetry.Group.regular_representation","title":"<code>regular_representation()</code>","text":"<p>Return the regular representation defined over the group.</p> <p>INPUT:</p> <ul> <li><code>self</code> -- Group ; a  Sage permutation group or a group of the class Group.</li> </ul> <p>OUTPUT: The regular representation defined over the Group given by self. </p> <p>EXAMPLES:</p> <p>We define the regular representation over the cyclic group of 4 elements ::</p> <pre><code>sage: G = Group(CyclicPermutationGroup(4)) \nsage: reg = G.regular_representation()\nsage: [reg(g) for g in G]\n[Linear transformation associated with element g=(), represented by the non-singular matrix:\n [1 0 0 0]\n [0 1 0 0]\n [0 0 1 0]\n [0 0 0 1]\n Representation space: Vector space of dimension 4 over Algebraic Field\n ,\n Linear transformation associated with element g=(1,2,3,4), represented by the non-singular matrix:\n [0 0 0 1]\n [1 0 0 0]\n [0 1 0 0]\n [0 0 1 0]\n Representation space: Vector space of dimension 4 over Algebraic Field\n ,\n Linear transformation associated with element g=(1,3)(2,4), represented by the non-singular matrix:\n [0 0 1 0]\n [0 0 0 1]\n [1 0 0 0]\n [0 1 0 0]\n Representation space: Vector space of dimension 4 over Algebraic Field\n ,\n Linear transformation associated with element g=(1,4,3,2), represented by the non-singular matrix:\n [0 1 0 0]\n [0 0 1 0]\n [0 0 0 1]\n [1 0 0 0]\n Representation space: Vector space of dimension 4 over Algebraic Field\n ]\n</code></pre> <p>We define the group of symmetries of regular hexagon and the regular representation over this group ::</p> <pre><code>sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\nsage: G = Group(generators)\nsage: reg = G.regular_representation()\nsage: g = G.an_element()\nsage: reg(g)\nLinear transformation associated with element g=(1,3)(4,6), represented by the non-singular matrix:\n[0 0 0 0 0 0 0 0 1 0 0 0]\n[0 0 0 0 0 0 1 0 0 0 0 0]\n[0 0 0 0 0 0 0 1 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 0 1]\n[0 0 0 0 0 0 0 0 0 1 0 0]\n[0 0 0 0 0 0 0 0 0 0 1 0]\n[0 1 0 0 0 0 0 0 0 0 0 0]\n[0 0 1 0 0 0 0 0 0 0 0 0]\n[1 0 0 0 0 0 0 0 0 0 0 0]\n[0 0 0 0 1 0 0 0 0 0 0 0]\n[0 0 0 0 0 1 0 0 0 0 0 0]\n[0 0 0 1 0 0 0 0 0 0 0 0]\nRepresentation space: Vector space of dimension 12 over Algebraic Field\n</code></pre> <p>We define the regular representation over the symmetric group of 4 simbols ::</p> <pre><code>sage: H = SymmetricGroup(4)\nsage: G = Group(H);\nsage: reg = G.regular_representation();\nsage: g = G.an_element()\nsage: reg(g)\nLinear transformation associated with element g=(1,3,4), represented by the non-singular matrix:\n24 x 24 dense matrix over Algebraic Field\nRepresentation space: Vector space of dimension 24 over Algebraic Field\n</code></pre> <p>REFERENCES:</p> <p>For more information, see the following references:</p> <ul> <li> <p>[Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.</p> </li> <li> <p>[Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.</p> </li> </ul> Source code in <code>pysymmetry/pysymmetry.py</code> <pre><code>def regular_representation(self):\n    r\"\"\"\n    Return the regular representation defined over the group.\n\n    INPUT:\n\n    - ``self`` -- Group ; a  Sage permutation group or a group of the class Group.\n\n    OUTPUT: The regular representation defined over the Group given by self. \n\n\n    EXAMPLES:\n\n    We define the regular representation over the cyclic group of 4 elements ::\n\n        sage: G = Group(CyclicPermutationGroup(4)) \n        sage: reg = G.regular_representation()\n        sage: [reg(g) for g in G]\n        [Linear transformation associated with element g=(), represented by the non-singular matrix:\n         [1 0 0 0]\n         [0 1 0 0]\n         [0 0 1 0]\n         [0 0 0 1]\n         Representation space: Vector space of dimension 4 over Algebraic Field\n         ,\n         Linear transformation associated with element g=(1,2,3,4), represented by the non-singular matrix:\n         [0 0 0 1]\n         [1 0 0 0]\n         [0 1 0 0]\n         [0 0 1 0]\n         Representation space: Vector space of dimension 4 over Algebraic Field\n         ,\n         Linear transformation associated with element g=(1,3)(2,4), represented by the non-singular matrix:\n         [0 0 1 0]\n         [0 0 0 1]\n         [1 0 0 0]\n         [0 1 0 0]\n         Representation space: Vector space of dimension 4 over Algebraic Field\n         ,\n         Linear transformation associated with element g=(1,4,3,2), represented by the non-singular matrix:\n         [0 1 0 0]\n         [0 0 1 0]\n         [0 0 0 1]\n         [1 0 0 0]\n         Representation space: Vector space of dimension 4 over Algebraic Field\n         ]\n\n    We define the group of symmetries of regular hexagon and the regular representation over this group ::\n\n        sage: generators = [\"(1,2,3,4,5,6)\",\"(1,4)(2,3)(5,6)\"]\n        sage: G = Group(generators)\n        sage: reg = G.regular_representation()\n        sage: g = G.an_element()\n        sage: reg(g)\n        Linear transformation associated with element g=(1,3)(4,6), represented by the non-singular matrix:\n        [0 0 0 0 0 0 0 0 1 0 0 0]\n        [0 0 0 0 0 0 1 0 0 0 0 0]\n        [0 0 0 0 0 0 0 1 0 0 0 0]\n        [0 0 0 0 0 0 0 0 0 0 0 1]\n        [0 0 0 0 0 0 0 0 0 1 0 0]\n        [0 0 0 0 0 0 0 0 0 0 1 0]\n        [0 1 0 0 0 0 0 0 0 0 0 0]\n        [0 0 1 0 0 0 0 0 0 0 0 0]\n        [1 0 0 0 0 0 0 0 0 0 0 0]\n        [0 0 0 0 1 0 0 0 0 0 0 0]\n        [0 0 0 0 0 1 0 0 0 0 0 0]\n        [0 0 0 1 0 0 0 0 0 0 0 0]\n        Representation space: Vector space of dimension 12 over Algebraic Field\n\n    We define the regular representation over the symmetric group of 4 simbols ::\n\n        sage: H = SymmetricGroup(4)\n        sage: G = Group(H);\n        sage: reg = G.regular_representation();\n        sage: g = G.an_element()\n        sage: reg(g)\n        Linear transformation associated with element g=(1,3,4), represented by the non-singular matrix:\n        24 x 24 dense matrix over Algebraic Field\n        Representation space: Vector space of dimension 24 over Algebraic Field\n\n\n    REFERENCES:\n\n    For more information, see the following references:\n\n    - [Ser1977]_Serre, Jean-Pierre. Linear representations of finite groups. Vol. 42. New York: springer, 1977.\n\n    - [Sti2012]_Stiefel, E., and A. F\u00e4ssler. Group theoretical methods and their applications. Springer Science &amp; Business Media, 2012.     \n\n    \"\"\"                \n\n\n    # usei metodos do orderpy pra deixar os calculos mais rapidos\n    #NOTA: precisa verificar se g esta em Group\n    matrices = [self._regular_(g).matrix() for g in self.gens()]\n    M = MatrixGroup(matrices)\n    return MapRepresentation(Hom(self, M), self._regular_)\n</code></pre>"}]}